# pglcmd.lib - shell functions for pglcmd -*-mode:shell-script-*-
#
# Copyright (C) 2005 - 2015 jre <jre-phoenix@users.sourceforge.net>
# Parts and ideas 2005 - 2007 by JFM, /meth/usr, lestlest (clessing), Morpheus
# and perhaps others. More Info: http://forums.phoenixlabs.org
#
# This file is part of pgl.
#
# pgl is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pgl is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pgl.  If not, see <http://www.gnu.org/licenses/>.


# Remember the pglcmd option (necessary for functions that use the original $1)
CMD_OPTION="$1"

# An regular expression for IPv4 addresses
IPv4_REGEX="[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}"

# Function to test if an external application exists.
# Usage: test_external basename_of_the_application
# Returns 0 if base is installed and executable in PATH
# Otherwise returns E_XEXTERNAL
# NOTE 1: "which" should not be used, because it is not available on all
#         systems, e.g. routers.
# NOTE 2: if the application is available externally and as shell builtin,
#         the builtin will be used. This may lead to undefined behaviour.
test_external () {
    IFS=":"
    for PATH_I in $PATH ; do
        [ -x "$PATH_I"/"$1" ] &&
            IFS=$STDIFS &&
            return 0
    done
    IFS=$STDIFS
    return $E_XEXTERNAL
}

test_sendmail () {
    if [ $SENDMAIL ] ; then
        if [ -x "$SENDMAIL" ] || test_external "$SENDMAIL" ; then
            true
        else
            echo "Warning: $SENDMAIL not found."
            echo "Check the SENDMAIL setting."
            return $E_XEXTERNAL
        fi
    fi
}

test_INIT () {
    case "$INIT" in
        '0'|'1')
            true
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the INIT setting."
            exit $E_CONFIG
            ;;
    esac
}

test_CRON () {
    case "$CRON" in
        '0'|'1')
            true
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the CRON setting."
            exit $E_CONFIG
            ;;
    esac
}

test_VERBOSE () {
    case "$VERBOSE" in
        '0'|'1'|'2')
            true
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the VERBOSE setting."
            exit $E_CONFIG
            ;;
    esac
}

test_DAEMON () {
    [ -x "$DAEMON" ] || {
            log_failure_msg "Error $E_XBIN: $DAEMON not installed."
            log_failure_msg "Could not detect $DESC daemon $NAME."
            log_failure_msg "Install it in PATH ($PATH) or specify DAEMON in $CMD_CONF."
            exit $E_XBIN
    }
}

test_CMD_PATHNAME () {
    [ -x "$CMD_PATHNAME" ] || {
        log_failure_msg "$0: $CMD_PATHNAME not installed."
        exit $E_XBIN
    }
}

test_LOG_SYSLOG () {
    case "$LOG_SYSLOG" in
        '0'|'1')
            true
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the LOG_SYSLOG setting."
            exit $E_CONFIG
            ;;
    esac
}

test_IPTABLES_TARGET () {
    case "$IPTABLES_TARGET" in
        'NFQUEUE')
            [ "$NFQUEUE_NUMBER" -ge 0 ] && [ "$NFQUEUE_NUMBER" -le 65535 ] || {
                log_failure_msg "Error $E_CONFIG: Check the NFQUEUE_NUMBER setting."
                exit $E_CONFIG
                }
            ;;
        # although QUEUE is deprecated, it is the same as NFQUEUE 0.
        'QUEUE')
            echo "Warning: ip_queue has been obsoleted by nfnetlink_queue."
            echo "You should replace in pglcmd.conf IPTABLES_TARGET=QUEUE with NFQUEUE."
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the IPTABLES_TARGET setting."
            exit $E_CONFIG
            ;;
    esac
}

# No test for REJECT_MARK. Valid: decimal and hexadecimal!?
# No test for REJECT_IN. Valid: all iptables targets
# No test for REJECT_OUT. Valid: all iptables targets
# No test for REJECT_FWD. Valid: all iptables targets

test_BLOCKLISTS_DIR () {
    [ -d "$BLOCKLISTS_DIR" ] || {
        echo -n "Creating missing directory $BLOCKLISTS_DIR ..."
        mkdir -p $BLOCKLISTS_DIR && echo "."
    } || {
        log_failure_msg "Error $E_XCD: Missing directory $BLOCKLISTS_DIR."
        log_failure_msg "Check the BLOCKLISTS_DIR setting."
        exit $E_XCD
    }
}

test_CMD_LOG () {
    [ -d "$(dirname $CMD_LOG)" ] || {
        echo -n "Creating missing directory $(dirname $CMD_LOG) ..."
        mkdir -p "$(dirname $CMD_LOG)" && echo "."
    } || {
        log_failure_msg "Error $E_XCD: Missing directory $(dirname $CMD_LOG)."
        log_failure_msg "Check the CMD_LOG setting."
        exit $E_XCD
    }
}

test_PIDFILE () {
    [ -d "$(dirname $PIDFILE)" ] || {
        log_failure_msg "Error $E_XCD: Missing directory $(dirname $PIDFILE)."
        log_failure_msg "$NAME needs a directory to write its pidfile to!"
        log_failure_msg "Check the PIDFILE setting."
        exit $E_XCD
    }
}

test_WD_PID () {
    [ -d "$(dirname $WD_PID)" ] || {
        log_failure_msg "Error $E_XCD: Missing directory $(dirname $WD_PID)."
        log_failure_msg "$(basename $WD_PATHNAME) needs a directory to write its pidfile to!"
        log_failure_msg "Check the WD_PID setting."
        exit $E_XCD
    }
}

test_WD_PATHNAME () {
    [ -x "$WD_PATHNAME" ] || {
        log_failure_msg "Error $E_CONFIG: Check the WD_PATHNAME setting."
        log_failure_msg "Not starting $(basename $WD_PATHNAME)."
        exit $E_CONFIG
        }
}

test_IPTABLES_VARS () {
    case "$IPTABLES_SETTINGS" in
        '0')
            true
            ;;
        '1')
            case "$IPTABLES_ACTIVATION" in
                '0'|'1'|'2')
                    true
                    ;;
                *)
                    log_failure_msg "Error $E_CONFIG: Check the IPTABLES_ACTIVATION setting."
                    exit $E_CONFIG
                    ;;
            esac
            case "$WHITE_LOCAL" in
                '0'|'1'|'2')
                    true
                    ;;
                *)
                    log_failure_msg "Error $E_CONFIG: Check the WHITE_LOCAL setting."
                    exit $E_CONFIG
                    ;;
            esac
            # No test for WHITE_TCP_IN. Valid: port number or associated service name
            # No test for WHITE_UDP_IN.
            # No test for WHITE_TCP_OUT.
            # No test for WHITE_UDP_OUT.
            # No test for WHITE_TCP_FWD.
            # No test for WHITE_UDP_FWD.
            # No test for INTERFACES.
            # No test for IP_REMOVE. Valid: all regular expressions for grep
            ;;
        '2')
            [ -d "$IPTABLES_CUSTOM_DIR" ] || {
                log_failure_msg "Error $E_XCD: Could not find $IPTABLES_CUSTOM_DIR."
                log_failure_msg "Check the IPTABLES_CUSTOM_DIR setting."
                exit $E_XCD
            }
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the IPTABLES_SETTINGS setting."
            exit $E_CONFIG
            ;;
    esac
}

# Test if user is root
test_root () {
    case "$(id -ru)" in
        '0')
            true
            ;;
        *)
            log_failure_msg "Error $E_NOTROOT: This program must be run as root."
            exit $E_NOTROOT
            ;;
    esac
}

# Sets NET_IPRANGE=1 if netfilter iprange is supported.
# Outputs warning and sets NET_IPRANGE=0 otherwise.
test_net_iprange () {
    # If module is missing only remember and warn about missing module.
    NET_IPRANGE=1
    [ -f /proc/net/ip_tables_matches ] && grep -q iprange /proc/net/ip_tables_matches ||
            modprobe -q xt_iprange ||
            modprobe -q ipt_iprange ||
            {
                log_warning_msg "Warning: Could not load kernel module xt_iprange."
                NET_IPRANGE="0"
            }
}

################################################################################
# Functions

# Try to download TESTHOST before blocklist updates.
# If this fails, pglcmd assumes that there is no network available, and thus
# aborts the update. The default configured site is also used to determine the
# user friendly blocklist names for iblocklist.com URLs.
test_net () {
    test_external wget || {
        log_failure_msg "Error $E_XEXTERNAL: wget not installed."
        exit $E_XEXTERNAL
        }
    # Create BLOCKLISTS_DIR if missing
    [ -d "$BLOCKLISTS_DIR" ] ||
        mkdir -p "$BLOCKLISTS_DIR" ||
        { log_failure_msg " Error: mkdir -p exited with $?" ; exit 1 ; }
    # Get TESTHOST (per default this is lists.xml from iblocklist,
    # which is later on parsed to figure out human readable listnames.
    # Save it first with a backup name.
    $WGET_OPTS -O "${BLOCKLISTS_DIR}/lists.xml~" $TESTHOST    # Don't quote WGET_OPTS!
    if [ "$?" -ne 0 ] ; then
        log_failure_msg "Error $E_NETWORK_DOWN: No connection to $TESTHOST. Aborting!"
        exit $E_NETWORK_DOWN
    fi
    # If file is valid rename it to original name.
    if [ "$( wc -l < ${BLOCKLISTS_DIR}/lists.xml~ )" -gt 0 ] ; then
        mv ${BLOCKLISTS_DIR}/lists.xml~ ${BLOCKLISTS_DIR}/lists.xml
    fi
}

# Calculate the routing prefix and its bits length for a given IP and subnetmask
# (convert ifconfig output to iptables output)
# e.g. IP=192.168.178.21 and SUBNETMASK=255.255.255.0 get 192.168.178.0/24
set_NETWORK () {
    local NETIP1 NETIP2 NETIP3 NETIP4 MASK1 MASK2 MASK3 MASK4 BITS
    [ $# -eq 2 ] || { echo "Internal error: Usage set_NETWORK IP SUBNETMASK, arguments were: \"${@}\"." ; exit 1 ; }
    echo $1 | grep -Eq "$IPv4_REGEX" || { echo "Internal error: $1 is not a valid IP!" ; exit 1 ; }
    echo $2 | grep -Eq "$IPv4_REGEX" || { echo "Internal error: $2 is not a valid SUBNETMASK!" ; exit 1 ; }

    IFS=.
    i=1
    for OCTET in $1 ; do
        eval NETIP${i}="${OCTET}"
        i=$(($i+1))
    done
    i=1
    for OCTET in $2 ; do
        eval MASK${i}="${OCTET}"
        i=$(($i+1))
    done
    IFS=$STDIFS

    # Use bitwise ANDing for the routing prefix
    NET1=$(( $NETIP1 & $MASK1 ))
    NET2=$(( $NETIP2 & $MASK2 ))
    NET3=$(( $NETIP3 & $MASK3 ))
    NET4=$(( $NETIP4 & $MASK4 ))

    # Haven't found a way to calculate this in a shell script. So using this table
    # for the bits length
    case $2 in
        255.0.0.0)        BITS="/8" ;;
        255.128.0.0)      BITS="/9" ;;
        255.192.0.0)      BITS="/10" ;;
        255.224.0.0)      BITS="/11" ;;
        255.240.0.0)      BITS="/12" ;;
        255.248.0.0)      BITS="/13" ;;
        255.252.0.0)      BITS="/14" ;;
        255.254.0.0)      BITS="/15" ;;
        255.255.0.0)      BITS="/16" ;;
        255.255.128.0)    BITS="/17" ;;
        255.255.192.0)    BITS="/18" ;;
        255.255.224.0)    BITS="/19" ;;
        255.255.240.0)    BITS="/20" ;;
        255.255.248.0)    BITS="/21" ;;
        255.255.252.0)    BITS="/22" ;;
        255.255.254.0)    BITS="/23" ;;
        255.255.255.0)    BITS="/24" ;;
        255.255.255.128)  BITS="/25" ;;
        255.255.255.192)  BITS="/26" ;;
        255.255.255.224)  BITS="/27" ;;
        255.255.255.240)  BITS="/28" ;;
        255.255.255.248)  BITS="/29" ;;
        255.255.255.252)  BITS="/30" ;;
        255.255.255.255)  BITS="" ;;
        *) { echo "Internal error: Cannot calculate bits length for ${2}!" ; exit 1 ; } ;;
    esac
    echo ${NET1}.${NET2}.${NET3}.${NET4}${BITS}
}

# Function to pass lines from an allowlist to allow_ip.
allow_list () {
    [ -n "$ALLOWLIST" ] || { echo "Internal error: allow_list ALLOWLIST not set." ; exit 1 ; }
    [ -f "$ALLOWLIST" ] || {
        log_failure_msg "Error $E_XFILE: allow_list ALLOWLIST $ALLOWLIST doesn't exist. Aborting!"
        exit $E_XFILE
        }
        echo -n " $ALLOWLIST" # Text before in insert_iptables: ....Allowing IPs
        # Read the non-comment|not-empty lines from the allow file:
        ALLOW="$(grep -Ev "^[[:space:]]*#|^[[:space:]]*$" $ALLOWLIST)"
        IFS=$'
' # Set IFS to newline only for LINE
        for LINE in $ALLOW ; do
            IFS=$STDIFS
            allow_ip
        done
        # Reset IFS again, in case ALLOW was empty.
        IFS=$STDIFS
}

# Function to add whitelisting rules from "for LINE in ...".
# Supports network IPs (IPv4/mask), single IPv4s and IPv4 ranges.
# The format is not specified explicitly. P2P and LOWMEM must work.
allow_ip () {
    [ -n "$LINE" ] || { echo "Internal error: allow_ip LINE not set." ; exit 1 ; }
    [ -n "$CMD_WHITE_IP" ] || { echo "Internal error: allow_ip CMD_WHITE_IP not set." ; exit 1 ; }
    [ -n "$CMD_WHITE_IPRANGE" ] || { echo "Internal error: allow_ip CMD_WHITE_IPRANGE not set." ; exit 1 ; }
    [ -n "$NET_IPRANGE" ] || { echo "Internal error: allow_ip NET_IPRANGE not set." ; exit 1 ; }
    IPRANGE_BEGIN=
    IPRANGE_END=
    NETWORK_IP=
    # Check every LINE
    # - ignore the comment part if it exists (everything before and including a colon ":")
    # - remember
    #   - the first and last IPv4
    #     If they are not identical assume an IP range (see
    #     https://sourceforge.net/p/peerguardian/wiki/dev-Main/#blocklist-format-specifications
    #     for some blocklist format specifications. Note that these are not exactly implemented,
    #     but are mainly caught by this general approach.
    #   - IPv4/mask, and assume a network IP address.
    IPRANGE_BEGIN="$(echo $LINE | sed "s|.*:||" | grep -Eo "$IPv4_REGEX" | head -n1)"
    IPRANGE_END="$(echo $LINE | sed "s|.*:||" | grep -Eo "$IPv4_REGEX" | tail -n1)"
    NETWORK_IP="$(echo $LINE | sed "s|.*:||" | grep -Eo "${IPv4_REGEX}/[0-9]{1,3}" | tail -n1)"
    [ x"$IPRANGE_BEGIN$IPRANGE_END$NETWORK_IP" != x ] || continue
    # Add whitelisting rule
    # (add 2 rules in the FORWARD chain: once for --src-range, once for --dst-range)
    if [ -n "$NETWORK_IP" ] ; then
        # Network ip address.
        for CMD in $CMD_WHITE_IP ; do
            iptables -I $PGL_CHAIN $CMD $NETWORK_IP -j $IPTABLES_TARGET_WHITELISTING ||
                fail_allow_ip
        done
    elif [ "$IPRANGE_BEGIN" = "$IPRANGE_END" ] ; then
        # Single IP, not an iprange.
        for CMD in $CMD_WHITE_IP ; do
            iptables -I $PGL_CHAIN $CMD $IPRANGE_BEGIN -j $IPTABLES_TARGET_WHITELISTING ||
                fail_allow_ip
        done
    elif [ "$IPRANGE_BEGIN" != "$IPRANGE_END" ] ; then
        # IP range.
        if [ "$NET_IPRANGE" = 1 ] ; then
            # netfilter iprange kernel support is available.
            for CMD in $CMD_WHITE_IPRANGE ; do
                iptables -I $PGL_CHAIN -m iprange $CMD $IPRANGE_BEGIN-$IPRANGE_END -j $IPTABLES_TARGET_WHITELISTING ||
                    fail_allow_ip
            done
        else
            log_failure_msg "Error $E_XEXTERNAL: Could not load kernel module xt_iprange!"
            log_failure_msg "Use a kernel with netfilter iprange support."
            fail_allow_ip
        fi
    else
        echo "DEBUG: Ignored line \"$LINE\". Please report if this is an error."
    fi
}

# To be called from allow_ip:
fail_allow_ip () {
    log_failure_msg "allow_ip: Could not handle \"$LINE\"."
    fail_insert_iptables
}

white_local () {
    # If CHAINS is empty/not set, then set it to "all". Replace all with the single names.
    CHAINS=${CHAINS:-all}
    [ "$CHAINS" != all ] || CHAINS="INPUT OUTPUT FORWARD"

    if [ "$WHITE_LOCAL" -ne 0 ] ; then
        # Whitelist loopback interface
        # TODO: Only do this if checking the loopback interface is enabled
        # (although otherwise just no traffic will ever get to the pgl_ chain were this rule is placed).
        # Do this only once on (re)start
        if [ "$CMD_OPTION" = start ] || [ "$CMD_OPTION" = restart ] ; then
            echo -n "..Allowing loopback traffic:"
            for CHAIN in $CHAINS ; do
                case $CHAIN in
                INPUT)
                    PGL_CHAIN="$IPTABLES_IN"
                    CMD_LOOP="-i lo"
                    ;;
                OUTPUT)
                    PGL_CHAIN="$IPTABLES_OUT"
                    CMD_LOOP="-o lo"
                    ;;
                FORWARD)
                    continue
                    ;;
                *)
                    echo " Unknown CHAIN $CHAIN specified."
                    exit 1
                    ;;
                esac
                echo -n " $CHAIN"
                # Insert whitelisting rules for whole loopback interface
                iptables -I $PGL_CHAIN $CMD_LOOP -j $IPTABLES_TARGET_WHITELISTING || fail_insert_iptables
            done
            log_end_msg 0
        fi

        # Whitelist the DNS server(s).
        # For this /etc/resolv.conf and the output of "iptables -L -nv" is scanned for certain patterns.
        if [ -f /etc/resolv.conf ] ; then
            # Get the DNS server's IP
            DNS_IPS="$( grep nameserver /etc/resolv.conf | grep -Eo "$IPv4_REGEX" )"

            # Insert whitelisting rules for DNS server.
            for CHAIN in $CHAINS ; do
                case $CHAIN in
                INPUT)
                    continue
                    ;;
                OUTPUT)
                    PGL_CHAIN="$IPTABLES_OUT"
                    ;;
                FORWARD)
                    PGL_CHAIN="$IPTABLES_FWD"
                    ;;
                esac

                for IP in $DNS_IPS ; do
                    echo -n "..Allowing $CHAIN traffic to DNS server $IP"
                    # Whitelist DNS server, if we do an inital start/restart (quick
                    # test of $CMD_OPTION) or if the DNS server is not already whitelisted
                    # (time-consuming test of iptables output).
                    # With other words:
                    # pglcmd start/restart: always whitelist DNS server
                    # if-up: first check if DNS server is already whitelisted.
                    if [ "$CMD_OPTION" = start ] || [ "$CMD_OPTION" = restart ] ||
                    ! iptables -nv -L $PGL_CHAIN | grep -F "$IP " | grep $IPTABLES_TARGET_WHITELISTING > /dev/null 2>&1 ; then
                        iptables -I $PGL_CHAIN --destination $IP -j $IPTABLES_TARGET_WHITELISTING
                        RETVAL=$?
                        log_end_msg $RETVAL
                        [ "$RETVAL" = 0 ] || exit $E_IPTABLES
                    else
                        echo ", already done."
                    fi
                done
            done
        fi
    fi

    if [ "$WHITE_LOCAL" -eq 1 ] ; then
        echo "..Allowing LAN traffic ..."
        # Automatically whitelist LAN of all up interfaces
        # TODO: Only do this if checking the corresponding interface is enabled
        # For this the output of "ifconfig" and "iptables -L -nv" is scanned for certain patterns
        # TODO: Use "ip addr" instead of ifconfig.

        # Get IPs of interfaces that are up
        LOCAL_IPS="$(ifconfig |
            grep -Eo "inet addr:$IPv4_REGEX" |
            grep -Eo "$IPv4_REGEX" )"
        for IP in $LOCAL_IPS ; do
            case $IP in
            127.*)
                # IP is a loopback IP. This was already done above.
                ;;
            *)
                # For all other IPs
                # Get the corresponding subnetmask
                # Use grep -F followed by a blank to match exactly a specific IP!
                SUBNETMASK="$(ifconfig |
                    grep -F "inet addr:${IP} " |
                    grep -Eo "Mask:${IPv4_REGEX}" |
                    grep -Eo "$IPv4_REGEX" )"
                # Set NETWORK as it will be shown by iptables
                NETWORK="$(set_NETWORK $IP $SUBNETMASK)"

                # Insert whitelisting rules for LAN with SUBNETMASK.
                for CHAIN in $CHAINS ; do
                    case $CHAIN in
                    INPUT)
                        PGL_CHAIN="$IPTABLES_IN"
                        CMD_WHITE_IP="--source ${IP}/${SUBNETMASK}"
                        DIRECTION="from"
                        ;;
                    OUTPUT)
                        PGL_CHAIN="$IPTABLES_OUT"
                        CMD_WHITE_IP="--destination ${IP}/${SUBNETMASK}"
                        DIRECTION="to"
                        ;;
                    FORWARD)
                        PGL_CHAIN="$IPTABLES_FWD"
                        # To whitelist all local FORWARD traffic add whitelisting rules from every single
                        # interface to every other interface.
                        for IP2 in $LOCAL_IPS ; do
                            # Skip if interface is loopback.
                            [ "$(echo "$IP2" | head -c 4)" = 127. ] && continue
                            # Get the corresponding subnetmask
                            # Use grep -F followed by a blank to match exactly a specific IP!
                            SUBNETMASK2="$(ifconfig |
                                grep -F "inet addr:${IP2} " |
                                grep -Eo "Mask:$IPv4_REGEX" |
                                grep -Eo "$IPv4_REGEX" )"
                            # Set NETWORK2 as it will be shown by iptables
                            NETWORK2="$(set_NETWORK $IP2 $SUBNETMASK2)"

                            echo -n "....$CHAIN from $NETWORK to $NETWORK2"
                            if [ "$CMD_OPTION" = start ] || [ "$CMD_OPTION" = restart ] ||
                            ! iptables -nv -L $PGL_CHAIN | grep "$IPTABLES_TARGET_WHITELISTING .* $NETWORK *$NETWORK2" > /dev/null 2>&1 ; then
                                iptables -I $PGL_CHAIN --source ${IP}/${SUBNETMASK} --destination ${IP2}/${SUBNETMASK2} -j $IPTABLES_TARGET_WHITELISTING
                                RETVAL=$?
                                log_end_msg $RETVAL
                                [ "$RETVAL" = 0 ] || exit $E_IPTABLES
                            else
                                echo ", already done."
                            fi
                        done
                        continue
                        ;;
                    esac
                    echo -n "....$CHAIN $DIRECTION $NETWORK"
                    # Whitelist LAN, if we do an inital start/restart (quick
                    # test of $CMD_OPTION) or if the LAN is not already whitelisted
                    # (time-consuming test of iptables output).
                    # With other words:
                    # pglcmd start/restart: always whitelist LAN
                    # if-up: first check iptables output if LAN is already whitelisted.
                    if [ "$CMD_OPTION" = start ] || [ "$CMD_OPTION" = restart ] ||
                    ! iptables -nv -L $PGL_CHAIN | grep "$IPTABLES_TARGET_WHITELISTING .* $NETWORK" > /dev/null 2>&1 ; then
                        iptables -I $PGL_CHAIN $CMD_WHITE_IP -j $IPTABLES_TARGET_WHITELISTING
                        RETVAL=$?
                        log_end_msg $RETVAL
                        [ "$RETVAL" = 0 ] || exit $E_IPTABLES
                    else
                        echo ", already done."
                    fi
                done
                ;;
            esac
        done
    echo "..LAN traffic allowed."
    fi
}

# Function to be executed if iptables insert command fails:
# - Removes all iptables rules again (if not in configure mode)
# - Aborts.
fail_insert_iptables () {
    log_end_msg $?
    if [ "$CMD_OPTION" != configure ] ; then
        # Try to build the REMOVE_SCRIPT in any case
        [ ! -e "${REMOVE_SCRIPT}" ] || cat ${REMOVE_SCRIPT} >> ${REMOVE_SCRIPT}.tmp
        mv ${REMOVE_SCRIPT}.tmp $REMOVE_SCRIPT
        delete_iptables
    fi
    exit $E_IPTABLES
}

# Called by "pglcmd configure" with $@.
configure () {

    OPT=
    OPTARG=
    VALUE=
    while [ "$#" -gt 0 ] ; do
        case $1 in
        configure)
            shift
            continue
            ;;
        --*)
            # Remember the option (and if permanent) for all following args.
            # Remove leading "--" and "permanent_" from the option, we only
            # work with the following part as OPT.
            OPT="$( echo "$1" | sed -e "s|--\(.*\)|\1|" -e "s|permanent_\(.*\)|\1|" )"
            if [ "$1" = "--permanent_$OPT" ] ; then
                permanent=1
            else
                permanent=0
            fi
            shift
            continue
            ;;
        *)
            if [ -z "$OPT" ] ; then
                usage # Error out if in "configure", but no OPT was given first.
            fi
            #Remove spaces from beginning and end of first arg
            OPTARG="$(echo "$1" | sed -e 's|[[:space:]]*||' -e 's|[[:space:]]*$||')"
            ;;
        esac

        if [ -z "$OPTARG" ] ; then
            shift
            continue
        fi

        case $OPT in
        add_allow_tcp_in)
            ADD_ALLOW_TCP_IN="$ADD_ALLOW_TCP_IN $OPTARG"
            [ "$permanent" = 0 ] || configure_permanent WHITE_TCP_IN
            ;;
        add_allow_tcp_out)
            ADD_ALLOW_TCP_OUT="$ADD_ALLOW_TCP_OUT $OPTARG"
            [ "$permanent" = 0 ] || configure_permanent WHITE_TCP_OUT
            ;;
        add_allow_tcp_fwd)
            ADD_ALLOW_TCP_FWD="$ADD_ALLOW_TCP_FWD $OPTARG"
            [ "$permanent" = 0 ] || configure_permanent WHITE_TCP_FWD
            ;;
        add_allow_udp_in)
            ADD_ALLOW_UDP_IN="$ADD_ALLOW_UDP_IN $OPTARG"
            [ "$permanent" = 0 ] || configure_permanent WHITE_UDP_IN
            ;;
        add_allow_udp_out)
            ADD_ALLOW_UDP_OUT="$ADD_ALLOW_UDP_OUT $OPTARG"
            [ "$permanent" = 0 ] || configure_permanent WHITE_UDP_OUT
            ;;
        add_allow_udp_fwd)
            ADD_ALLOW_UDP_FWD="$ADD_ALLOW_UDP_FWD $OPTARG"
            [ "$permanent" = 0 ] || configure_permanent WHITE_UDP_FWD
            ;;
        add_allow_ip_in)
            ADD_ALLOW_IP_IN="$ADD_ALLOW_IP_IN $OPTARG"
            [ "$permanent" = 0 ] || configure_permanent WHITE_IP_IN
            ;;
        add_allow_ip_out)
            ADD_ALLOW_IP_OUT="$ADD_ALLOW_IP_OUT $OPTARG"
            [ "$permanent" = 0 ] || configure_permanent WHITE_IP_OUT
            ;;
        add_allow_ip_fwd)
            ADD_ALLOW_IP_FWD="$ADD_ALLOW_IP_FWD $OPTARG"
            [ "$permanent" = 0 ] || configure_permanent WHITE_IP_FWD
            ;;
        drop_allow_tcp_in)
            DROP_ALLOW_TCP_IN="$DROP_ALLOW_TCP_IN $OPTARG"
            [ "$permanent" = 0 ] || configure_permanent WHITE_TCP_IN
            ;;
        drop_allow_tcp_out)
            DROP_ALLOW_TCP_OUT="$DROP_ALLOW_TCP_OUT $OPTARG"
            [ "$permanent" = 0 ] || configure_permanent WHITE_TCP_OUT
            ;;
        drop_allow_tcp_fwd)
            DROP_ALLOW_TCP_FWD="$DROP_ALLOW_TCP_FWD $OPTARG"
            [ "$permanent" = 0 ] || configure_permanent WHITE_TCP_FWD
            ;;
        drop_allow_udp_in)
            DROP_ALLOW_UDP_IN="$DROP_ALLOW_UDP_IN $OPTARG"
            [ "$permanent" = 0 ] || configure_permanent WHITE_UDP_IN
            ;;
        drop_allow_udp_out)
            DROP_ALLOW_UDP_OUT="$DROP_ALLOW_UDP_OUT $OPTARG"
            [ "$permanent" = 0 ] || configure_permanent WHITE_UDP_OUT
            ;;
        drop_allow_udp_fwd)
            DROP_ALLOW_UDP_FWD="$DROP_ALLOW_UDP_FWD $OPTARG"
            [ "$permanent" = 0 ] || configure_permanent WHITE_UDP_FWD
            ;;
        drop_allow_ip_in)
            DROP_ALLOW_IP_IN="$DROP_ALLOW_IP_IN $OPTARG"
            [ "$permanent" = 0 ] || configure_permanent WHITE_IP_IN
            ;;
        drop_allow_ip_out)
            DROP_ALLOW_IP_OUT="$DROP_ALLOW_IP_OUT $OPTARG"
            [ "$permanent" = 0 ] || configure_permanent WHITE_IP_OUT
            ;;
        drop_allow_ip_fwd)
            DROP_ALLOW_IP_FWD="$DROP_ALLOW_IP_FWD $OPTARG"
            [ "$permanent" = 0 ] || configure_permanent WHITE_IP_FWD
            ;;
        set_var)
            if [ -z "$OPTARG" ] || [ "$#" -ne 2 ] ; then
                usage
            fi

            shift
            #Remove spaces from beginning and end of first arg
            VALUE="$(echo "$1" | sed -e 's|[[:space:]]*||' -e 's|[[:space:]]*$||')"

            #Check if variable already exists in pglcmd.conf
            if  grep -q "^[[:space:]]*$OPTARG=" "$CMD_CONF"; then
                sed -i "s|^[[:space:]]*$OPTARG=.*|$OPTARG=\"$VALUE\"|g" "$CMD_CONF"
            else
                # Add a newline at end of file if it was missing.
                sed -i -e '$a\' "$CMD_CONF"
                # Add VAR with OPTARG set to pglcmd.conf.
                echo "$OPTARG=\"$VALUE\"" >> "$CMD_CONF"
            fi
            ;;
        *)
            echo "Invalid option: $1"
            usage
            ;;
        esac

        shift
    done

    # If any ADD_ALLOW_ variable is set ...
    if [ -n "$ADD_ALLOW_TCP_IN" ] ||
       [ -n "$ADD_ALLOW_TCP_OUT" ] ||
       [ -n "$ADD_ALLOW_TCP_FWD" ] ||
       [ -n "$ADD_ALLOW_UDP_IN" ] ||
       [ -n "$ADD_ALLOW_UDP_OUT" ] ||
       [ -n "$ADD_ALLOW_UDP_FWD" ] ||
       [ -n "$ADD_ALLOW_IP_IN" ] ||
       [ -n "$ADD_ALLOW_IP_OUT" ] ||
       [ -n "$ADD_ALLOW_IP_FWD" ] ; then

        if status_of_proc $DAEMON $NAME > /dev/null 2>&1 ; then
            IPTABLES_MODE=add
            WHITE_TCP_IN="$ADD_ALLOW_TCP_IN"
            WHITE_TCP_OUT="$ADD_ALLOW_TCP_OUT"
            WHITE_TCP_FWD="$ADD_ALLOW_TCP_FWD"
            WHITE_UDP_IN="$ADD_ALLOW_UDP_IN"
            WHITE_UDP_OUT="$ADD_ALLOW_UDP_OUT"
            WHITE_UDP_FWD="$ADD_ALLOW_UDP_FWD"
            WHITE_IP_IN="$ADD_ALLOW_IP_IN"
            WHITE_IP_OUT="$ADD_ALLOW_IP_OUT"
            WHITE_IP_FWD="$ADD_ALLOW_IP_FWD"
            insert_iptables
        else
            echo "$DAEMON is not running, not changing the iptables rules."
        fi
    fi

    # If any DROP_ALLOW_ variable is set ...
    if [ -n "$DROP_ALLOW_TCP_IN" ] ||
       [ -n "$DROP_ALLOW_TCP_OUT" ] ||
       [ -n "$DROP_ALLOW_TCP_FWD" ] ||
       [ -n "$DROP_ALLOW_UDP_IN" ] ||
       [ -n "$DROP_ALLOW_UDP_OUT" ] ||
       [ -n "$DROP_ALLOW_UDP_FWD" ] ||
       [ -n "$DROP_ALLOW_IP_IN" ] ||
       [ -n "$DROP_ALLOW_IP_OUT" ] ||
       [ -n "$DROP_ALLOW_IP_FWD" ] ; then
        if status_of_proc $DAEMON $NAME > /dev/null 2>&1 ; then
            IPTABLES_MODE=remove
            WHITE_TCP_IN="$DROP_ALLOW_TCP_IN"
            WHITE_TCP_OUT="$DROP_ALLOW_TCP_OUT"
            WHITE_TCP_FWD="$DROP_ALLOW_TCP_FWD"
            WHITE_UDP_IN="$DROP_ALLOW_UDP_IN"
            WHITE_UDP_OUT="$DROP_ALLOW_UDP_OUT"
            WHITE_UDP_FWD="$DROP_ALLOW_UDP_FWD"
            WHITE_IP_IN="$DROP_ALLOW_IP_IN"
            WHITE_IP_OUT="$DROP_ALLOW_IP_OUT"
            WHITE_IP_FWD="$DROP_ALLOW_IP_FWD"
            insert_iptables
        else
            echo "$DAEMON is not running, not changing the iptables rules."
        fi
    fi

}

# Called from "pglcmd configure" to write changed settings to pglcmd.conf.
configure_permanent() {
    local is_present=no SEARCHTERMS= VALUE= VALUES= LOCAL_ALLOWLISTS= CONN=

    [ -n "$OPT" ] || { echo "Internal error: configure_permanent OPT not set." ; exit 1 ; }
    [ -n "$OPTARG" ] || { echo "Internal error: configure_permanent OPTARG not set." ; exit 1 ; }
    [ "$#" = 1 ] || { echo "Internal error: Usage \"configure_permanent VARIABLE\", arguments were: \"${@}\"." ; exit 1 ; }

    case $OPT in
    *tcp*)
        PROTO=tcp
        ;;
    *udp*)
        PROTO=udp
        ;;
    *ip*)
        PROTO=
        ;;
    *)
        echo "Internal error: configure_permanent OPT $OPT not known."
        exit 1
        ;;
    esac

    # Find the SEARCHTERMS (based on OPTARG) that we are looking for.
    if [ -n "$PROTO" ] && [ -f /etc/services ] ; then # Working on ports and port-mapping file exists.
        # SEARCHTERMS is the port number and the corresponding servicenames/whatever (column 1 and 3 of /etc/services)
        if [ "$OPTARG" -gt 0 ] 2>/dev/null ; then # OPTARG is a portnumber.
            # Only take the one line matching " port/proto" (with space in front of port, because 8080 != 80) in /etc/services,
            # then remove /proto and comments.
            # Note: command always succeeds because last command sed always succeeds.
            SEARCHTERMS="$(grep "^.*[[:space:]]${OPTARG}/${PROTO}" /etc/services | sed "s|/${PROTO}||;s|#.*||")"
        else # OPTARG is a servicename.
            # line 1: only lines matching PROTO
            # line 2: remove /proto and comments
            # line 3: only match whole word, defined by 3 possibilities: surrounded by
            #         - line-beginning and whitespace
            #         - whitespace and whitespace
            #         - whitespace and end of line
            SEARCHTERMS="$(grep $PROTO /etc/services |
                        sed "s|#.*||g;s|/${PROTO}||g" |
                        grep -E "^$OPTARG[[:space:]]{1,}|[[:space:]]{1,}$OPTARG[[:space:]]{1,}|[[:space:]]{1,}$OPTARG$" || true )"
        fi
    elif [ -z "$PROTO" ] ; then # Working on IPs
        SEARCHTERMS=$(echo "$OPTARG" | sed -r "s|^(.*:)?[[:space:]]*||") # Ignore any descriptions
    fi
    # SEARCHTERM is still empty if nothing was found in /etc/services.
    [ -n "$SEARCHTERMS" ] || SEARCHTERMS="$OPTARG"

    # OPT            is the option given to "pglcmd configure", e.g. add_allow_tcp_out
    # $1             is the corresponding VARIABLE name, e.g. WHITE_IP_OUT
    # OPTARG         is the value that we want to add/drop, e.g. 80 or 123.123.123.123[/24]
    # eval echo \$$1 is the current value of the VARIABLE. Using eval here should be safe,
    #                because it works on internally set $1 without any public interface.
    case $OPT in
    add_allow_tcp*|add_allow_udp*)
        for i in $SEARCHTERMS ; do          # Check if the value (or corresponding values) ...
            for j in $(eval echo \$$1) ; do # ... is already present in the VARIABLE.
                if [ "$i" = "$j" ] ; then
                    is_present=yes
                    break
                fi
            done
            [ "$is_present" = no ] || break  # break if is_present=yes
        done

        if grep -q "^[[:space:]]*$1=" "$CMD_CONF" ; then # Variable ($1) is set in pglcmd.conf.
            if [ "$is_present" = no ] ; then
                # Add VALUE to VARIABLE values in pglcmd.conf.
                sed -i "s|^[[:space:]]*$1=.*|$1=\"$(eval echo \$$1) $OPTARG\"|g" "$CMD_CONF"
            fi
        else # VARIABLE is not set in pglcmd.conf.
            # Add a newline at end of file if it was missing.
            sed -i -e '$a\' "$CMD_CONF"
            # Add VAR with OPTARG set to pglcmd.conf.
            echo "$1=\"$OPTARG\"" >> "$CMD_CONF"
        fi
        ;;
    add_allow_ip*)
        # SEARCHTERMS is the non-comment part of OPTARG
        # LOCAL_ALLOWLISTS is LOCAL_ALLOWLISTS_[IN|OUT|FWD]_DIR/pgl.p2p (one file here!)

        CONN="$(echo "$1" | sed 's|WHITE_IP_\([A-Z]*\)|\1|')"
        LOCAL_ALLOWLISTS="LOCAL_ALLOWLISTS_${CONN}_DIR"
        LOCAL_ALLOWLISTS="$(eval echo \$${LOCAL_ALLOWLISTS})"
        LOCAL_ALLOWLISTS="${LOCAL_ALLOWLISTS}/pgl.p2p"

        # Check for SEARCHTERMS, and make sure that LOCAL_ALLOWLISTS
        # exists and ends with a newline.
        if [ -f "$LOCAL_ALLOWLISTS" ] ; then
            # grep only matches whole lines.
            if grep -E -x "[[:space:]]*[^#].*" "$LOCAL_ALLOWLISTS" | grep -E -qx "^(.*:)?[[:space:]]*$SEARCHTERMS[[:space:]]*$" "$LOCAL_ALLOWLISTS" ; then
                is_present=yes
            else
                # Add a newline at end of file if it was missing.
                sed -i -e '$a\' "$LOCAL_ALLOWLISTS"
            fi
        elif  [ -d "$(dirname $LOCAL_ALLOWLISTS)" ] ; then
            touch "$LOCAL_ALLOWLISTS"
        else
            mkdir -p "$(dirname $LOCAL_ALLOWLISTS)"
            touch "$LOCAL_ALLOWLISTS"
        fi

        if [ "$is_present" = no ] ; then
            # Add OPTARG to allowlist
            echo "$OPTARG" >> "$LOCAL_ALLOWLISTS"
        else
            # Update the description in the lines matching the IP part.
            sed -i -r '/^[[:space:]]*#/! s|^(.*:)?[[:space:]]*'"$SEARCHTERMS"'[[:space:]]*$|'"$OPTARG"'|' "$LOCAL_ALLOWLISTS"
        fi
        ;;
    drop_allow_tcp*|drop_allow_udp*)
        if grep -q "^[[:space:]]*$1=" "$CMD_CONF" ; then # VARIABLE ($1) is set in pglcmd.conf.
            local update_variable=no
            for i in $(eval echo \$$1) ; do          # Go through all values in VARIABLE
                is_present=no
                for j in $SEARCHTERMS ; do                   # Check if the value is in the values to remove
                    if [ "$i" = "$j" ] ; then
                        is_present=yes
                        break
                    fi
                done

                if [ "$is_present" != yes ] ; then
                    VALUES="$VALUES $i"
                else
                    update_variable=yes
                fi
            done

            if [ "$update_variable" = yes ] ; then
                #Remove spaces from beginning and end of string
                VALUES="$(echo "$VALUES" | sed 's|[[:space:]]*\([^[[:space:]]]*.*[^[[:space:]]]*\)[[:space:]]*|\1|')"
                # Remove VALUE from VARIABLE values in pglcmd.conf.
                sed -i "s|^[[:space:]]*$1=.*|$1=\"$VALUES\"|g" "$CMD_CONF"
            fi
        fi
        ;;
    drop_allow_ip*)
        # SEARCHTERMS is the non-comment part of OPTARG
        # LOCAL_ALLOWLISTS is LOCAL_ALLOWLISTS_[IN|OUT|FWD]_DIR/pgl.p2p (one file here!)
        
        CONN="$(echo "$1" | sed 's|WHITE_IP_\([A-Z]*\)|\1|')"
        LOCAL_ALLOWLISTS="LOCAL_ALLOWLISTS_${CONN}_DIR"
        LOCAL_ALLOWLISTS="$(eval echo \$${LOCAL_ALLOWLISTS})"
        LOCAL_ALLOWLISTS="${LOCAL_ALLOWLISTS}/pgl.p2p"

        # Remove lines matching in their IP part SEARCHTERMS.
        if [ -f "$LOCAL_ALLOWLISTS" ] &&
            grep -E -qx "^[[:space:]]*([^#[:space:]].*:)?[[:space:]]*$SEARCHTERMS[[:space:]]*$" "$LOCAL_ALLOWLISTS"; then
            # TODO: set a trap to remove on fail
            TMP="$(mktemp)"
            grep -E -vx "^[[:space:]]*([^#[:space:]].*:)?[[:space:]]*$SEARCHTERMS[[:space:]]*$" "$LOCAL_ALLOWLISTS" > "$TMP"
            # Use cat to preserve file permissions and ownership.
            # TODO: Check best practices.
            cat "$TMP" > "$LOCAL_ALLOWLISTS"
        fi
        ;;
    esac

    # Reload conf
    . "$CMD_CONF"
}

# Set REMOVE_SCRIPT needed by insert_iptables and delete_iptables
REMOVE_SCRIPT="$MASTER_BLOCKLIST_DIR/.${CMD_NAME}.iptables.remove.sh"

# Function that inserts the iptables rules
# This is designed to be called on "start". If necessary make exceptions if it is
# called from another command, e.g. "configure".
insert_iptables () {

    # test_IPTABLES_VARS # Already tested in do_start
    test_external iptables || {
        log_failure_msg "Error $E_XEXTERNAL: iptables not installed."
        exit $E_XEXTERNAL
        }

    if [ "$CMD_OPTION" != configure ] && [ -f "$REMOVE_SCRIPT" ] ; then
        echo -n "Old iptables remove script $REMOVE_SCRIPT exists. Strange. Executing"
        sh $REMOVE_SCRIPT
        echo -n " and removing it"
        rm $REMOVE_SCRIPT
        log_end_msg $?
    fi

    case "$IPTABLES_SETTINGS" in

    '0')
        test_VERBOSE
        if [ "$VERBOSE" -eq 1 ] ; then
            log_warning_msg "$(basename $0) is configured not to insert iptables rules."
        fi
        ;;

    # Place iptables rules in separate iptables chains (pgl_in, pgl_out and pgl_fwd).
    '1')
        # If not set, set IPTABLES_MODE to default "add".
        IPTABLES_MODE=${IPTABLES_MODE:-add}
        if [ "$CMD_OPTION" = configure ] && [ "$IPTABLES_MODE" = remove ] ; then
            echo "Removing some iptables rules ..."
        else
            echo "Inserting iptables ..."
        fi

        # Variable tests
        test_IPTABLES_TARGET

        # Set constant variables for iptables commands
        case "$IPTABLES_TARGET" in
        NFQUEUE)
            IPTABLES_TARGET_BLOCK="$IPTABLES_TARGET --queue-num $NFQUEUE_NUMBER"
            ;;
        QUEUE)
            IPTABLES_TARGET_BLOCK="$IPTABLES_TARGET"
            ;;
        esac

        # If CHAINS is empty/not set, then set it to "all". Replace all with the single names.
        CHAINS=${CHAINS:-all}
        [ "$CHAINS" != all ] || CHAINS="INPUT OUTPUT FORWARD"

        # Prepare and issue iptables commands for every chain.
        for CHAIN in $CHAINS ; do
            echo "..Setting up iptables for $CHAIN:"
            case $CHAIN in
            INPUT)
                PGL_CHAIN="$IPTABLES_IN"
                WHITE_IP="$WHITE_IP_IN"
                WHITE_TCP="$WHITE_TCP_IN" # read from conffile or set by "configure"
                WHITE_UDP="$WHITE_UDP_IN" # read from conffile or set by "configure"
                CMD_WHITE_IP="--source"
                CMD_WHITE_IPRANGE="--src-range"
                if [ "$CMD_OPTION" = configure ] ; then
                    LOCAL_ALLOWLISTS="${LOCAL_ALLOWLISTS_IN_DIR}/pgl.p2p"
                else
                    set_LOCAL_ALLOWLISTS_IN
                    LOCAL_ALLOWLISTS="$LOCAL_ALLOWLISTS_IN"
                fi
                LOCAL_ALLOWLISTS="$LOCAL_ALLOWLISTS_IN"
                REJECT_TARGET="$REJECT_IN"
                ;;
            OUTPUT)
                PGL_CHAIN="$IPTABLES_OUT"
                WHITE_IP="$WHITE_IP_OUT"
                WHITE_TCP="$WHITE_TCP_OUT" # read from conffile or set by "configure"
                WHITE_UDP="$WHITE_UDP_OUT" # read from conffile or set by "configure"
                CMD_WHITE_IP="--destination"
                CMD_WHITE_IPRANGE="--dst-range"
                if [ "$CMD_OPTION" = configure ] ; then
                    LOCAL_ALLOWLISTS="${LOCAL_ALLOWLISTS_OUT_DIR}/pgl.p2p"
                else
                    set_LOCAL_ALLOWLISTS_OUT
                    LOCAL_ALLOWLISTS="$LOCAL_ALLOWLISTS_OUT"
                fi
                REJECT_TARGET="$REJECT_OUT"
                ;;
            FORWARD)
                PGL_CHAIN="$IPTABLES_FWD"
                WHITE_IP="$WHITE_IP_FWD"
                WHITE_TCP="$WHITE_TCP_FWD" # read from conffile or set by "configure"
                WHITE_UDP="$WHITE_UDP_FWD" # read from conffile or set by "configure"
                CMD_WHITE_IP="--source --destination"
                CMD_WHITE_IPRANGE="--src-range --dst-range"
                if [ "$CMD_OPTION" = configure ] ; then
                    LOCAL_ALLOWLISTS="${LOCAL_ALLOWLISTS_FWD_DIR}/pgl.p2p"
                else
                    set_LOCAL_ALLOWLISTS_FWD
                    LOCAL_ALLOWLISTS="$LOCAL_ALLOWLISTS_FWD"
                fi
                REJECT_TARGET="$REJECT_FWD"
                ;;
            *)
                echo " Unknown CHAIN $CHAIN specified."
                exit 1
                ;;
            esac

            if [ "$CMD_OPTION" != configure ] ; then

                # Create new pgl_ chain and remember iptables removal rules.
                # Remember the removal command before actually inserting, because one of the possible reasons for
                # the iptables command to fail is that the chain already exists (for whatever reason).
                echo -n "....Creating chain"
                echo "iptables -F $PGL_CHAIN" >> $REMOVE_SCRIPT &&
                echo "iptables -X $PGL_CHAIN" >> $REMOVE_SCRIPT &&
                iptables -N $PGL_CHAIN || fail_insert_iptables

                # Insert NFQUEUE rule.
                echo -n " and inserting $IPTABLES_TARGET rule"
                iptables -I $PGL_CHAIN -j $IPTABLES_TARGET_BLOCK &&
                log_end_msg "$?" || fail_insert_iptables

                # Port Whitelisting
                if [ -n "$WHITE_TCP" ] || [ -n "$WHITE_UDP" ] ; then
                    echo -n "....Whitelisting ports"
                    for PORT in $WHITE_TCP ; do
                        iptables -I $PGL_CHAIN -p tcp --dport $PORT -j $IPTABLES_TARGET_WHITELISTING || fail_insert_iptables
                    done
                    for PORT in $WHITE_UDP ; do
                        iptables -I $PGL_CHAIN -p udp --dport $PORT -j $IPTABLES_TARGET_WHITELISTING || fail_insert_iptables
                    done
                    log_end_msg "$?"
                fi

            else # in configure mode
                # The port and ip whitelisting rules from above, but
                # - always with a test if necessary,
                # - reversed logic if in remove mode (NOT_IF_REMOVE).

                # Port Whitelisting
                if [ -n "$WHITE_TCP" ] || [ -n "$WHITE_UDP" ] ; then
                    echo -n "....Whitelisting ports"
                    for PORT in $WHITE_TCP ; do

                        if ! [ "$PORT" -gt 0 ] 2>/dev/null ; then # Port is not a number, try to find it in /etc/services.
                            # line 1: only lines matching PROTO
                            # line 2: strip comments
                            # line 3: only match whole PORT, defined by 3 possibilities: surrounded by
                            #         - line-beginning and whitespace
                            #         - whitespace and whitespace
                            #         - whitespace and end of line
                            # line 4: take only numbers/PROTO
                            # line 5: strip PROTO
                            PORT_NEW="$( grep tcp /etc/services |
                                         sed "s|#.*||" |
                                         grep -E "^$PORT[[:space:]]{1,}|[[:space:]]{1,}$PORT[[:space:]]{1,}|[[:space:]]{1,}$PORT$" |
                                         grep -o "[[:digit:]]*/tcp" |
                                         sed "s|/tcp||" )"
                            if [ "$PORT_NEW" -gt 0 ] ; then
                                PORT="$PORT_NEW"
                            else
                                echo "Error: PORT_NEW $PORT_NEW for PORT $PORT is not a number."
                                exit "$E_BADARGS"
                            fi
                        fi

                        if [ "$IPTABLES_MODE" = add ] ; then
                            iptables -L $PGL_CHAIN -n | grep -Exq ".*$IPTABLES_TARGET_WHITELISTING *tcp *-- *0.0.0.0/0 *0.0.0.0/0 *tcp dpt:$PORT *" ||
                            iptables -I $PGL_CHAIN -p tcp --dport $PORT -j $IPTABLES_TARGET_WHITELISTING || fail_insert_iptables
                        else
                            ! iptables -L $PGL_CHAIN -n | grep -Exq ".*$IPTABLES_TARGET_WHITELISTING *tcp *-- *0.0.0.0/0 *0.0.0.0/0 *tcp dpt:$PORT *" ||
                            iptables -D $PGL_CHAIN -p tcp --dport $PORT -j $IPTABLES_TARGET_WHITELISTING || fail_insert_iptables
                        fi
                    done
                    for PORT in $WHITE_UDP ; do

                        if ! [ "$PORT" -gt 0 ] 2>/dev/null ; then # Port is not a number, try to find it in /etc/services.
                            # line 1: only lines matching PROTO
                            # line 2: strip comments
                            # line 3: only match whole PORT, defined by 3 possibilities: surrounded by
                            #         - line-beginning and whitespace
                            #         - whitespace and whitespace
                            #         - whitespace and end of line
                            # line 4: take only numbers/PROTO
                            # line 5: strip PROTO
                            PORT_NEW="$( grep udp /etc/services |
                                         sed "s|#.*||" |
                                         grep -E "^$PORT[[:space:]]{1,}|[[:space:]]{1,}$PORT[[:space:]]{1,}|[[:space:]]{1,}$PORT$" |
                                         grep -o "[[:digit:]]*/udp" |
                                         sed "s|/udp||" )"
                            if [ "$PORT_NEW" -gt 0 ] ; then
                                PORT="$PORT_NEW"
                            else
                                echo "Error: PORT_NEW $PORT_NEW for PORT $PORT is not a number."
                                exit "$E_BADARGS"
                            fi
                        fi

                        if [ "$IPTABLES_MODE" = add ] ; then
                            iptables -L $PGL_CHAIN -n | grep -Exq ".*$IPTABLES_TARGET_WHITELISTING *udp *-- *0.0.0.0/0 *0.0.0.0/0 *udp dpt:$PORT *" ||
                            iptables -I $PGL_CHAIN -p udp --dport $PORT -j $IPTABLES_TARGET_WHITELISTING || fail_insert_iptables
                        else
                            ! iptables -L $PGL_CHAIN -n | grep -Exq ".*$IPTABLES_TARGET_WHITELISTING *udp *-- *0.0.0.0/0 *0.0.0.0/0 *udp dpt:$PORT *" ||
                            iptables -D $PGL_CHAIN -p udp --dport $PORT -j $IPTABLES_TARGET_WHITELISTING || fail_insert_iptables
                        fi

                    done
                    log_end_msg "$?"
                fi

                # IP Whitelisting
                if [ -n "$WHITE_IP" ] ; then
                    echo -n "....Whitelisting IPs"
                    for IP in $WHITE_IP ; do
                        # Add whitelisting rule
                        # (add 2 rules in the FORWARD chain: once for --source, once for --destination)
                        for CMD in $CMD_WHITE_IP ; do
                            if [ "$CMD" = --source ] ; then
                                if [ "$IPTABLES_MODE" = add ] ; then
                                    iptables -L $PGL_CHAIN -n | grep -Exq ".*$IPTABLES_TARGET_WHITELISTING *all *-- *$IP *0.0.0.0/0 *" ||
                                    iptables -I $PGL_CHAIN $CMD $IP -j $IPTABLES_TARGET_WHITELISTING || fail_insert_iptables
                                else
                                    #Loop through all matches to delete IP duplicates
                                    iptables -L $PGL_CHAIN -n | grep -Ex ".*$IPTABLES_TARGET_WHITELISTING *all *-- *$IP *0.0.0.0/0 *" | while read line; do
                                        iptables -D $PGL_CHAIN $CMD $IP -j $IPTABLES_TARGET_WHITELISTING || fail_insert_iptables
                                    done
                                fi
                            fi
                            if [ "$CMD" = --destination ] ; then
                                if [ "$IPTABLES_MODE" = add ] ; then
                                    iptables -L $PGL_CHAIN -n | grep -Exq ".*$IPTABLES_TARGET_WHITELISTING *all *-- *0.0.0.0/0 *$IP *" ||
                                    iptables -I $PGL_CHAIN $CMD $IP -j $IPTABLES_TARGET_WHITELISTING || fail_insert_iptables
                                else
                                    #Loop through all matches to delete IP duplicates
                                    iptables -L $PGL_CHAIN -n | grep -Ex ".*$IPTABLES_TARGET_WHITELISTING *all *-- *0.0.0.0/0 *$IP *" | while read line; do
                                        iptables -D $PGL_CHAIN $CMD $IP -j $IPTABLES_TARGET_WHITELISTING || fail_insert_iptables;
                                    done
                                fi
                            fi
                        done
                    done
                    log_end_msg "$?"
                fi

                continue
            fi

            # Nothing left to do for configure insert_iptables, leave the loop, can't leave the function here.
            [ "$CMD_OPTION" != configure ] || return

            # Allowlist whitelisting.
            if [ -n "$LOCAL_ALLOWLISTS" ] ; then
                echo -n "....Allowing IPs"
                # Sets NET_IPRANGE=1 if netfilter iprange is supported.
                # Outputs warning and sets NET_IPRANGE=0 otherwise.
                test_net_iprange
                for ALLOWLIST in $LOCAL_ALLOWLISTS ; do
                    allow_list
                done
                log_end_msg "$?"
            fi

            # Block "Marked block" packages: "Marked block" packages are sent back
            # to the head of the chain again (NF_REPEAT repeats the hook function)
            # by pgld. Block them at the head of the pglcmd_* chains.
            # Alternatively they could be blocked at the head of the
            # INPUT/OUTPUT/FORWARD chains, but I decided against that in order to
            # keep those chains cleaner. It has to be made sure that the MARK of the
            # packets is not changed by other iptables rules.
            echo -n "....Inserting block rule"
            iptables -I $PGL_CHAIN -m mark --mark $REJECT_MARK -j $REJECT_TARGET || fail_insert_iptables
            # Log "Marked block" packages: The log-iptables-rules should be
            # placed directly before the block-iptables-rules (i.e. Insert them
            # directly after them)
            if [ -n "$LOG_IPTABLES" ] ; then    # string is not empty
                echo -n " and log rule"
                iptables -I $PGL_CHAIN -m mark --mark $REJECT_MARK -j $LOG_IPTABLES || fail_insert_iptables
            fi
            log_end_msg "$?"
        done

        # Nothing left to do for configure insert_iptables, leave the function.
        [ "$CMD_OPTION" != configure ] || return

        # Automatically whitelist LAN of all up interfaces, loopback interface
        # and DNS server(s) (if configured)
        white_local

        # If custom iptables insertion scripts exist, execute them:
        CUSTOM_INSERT_SCRIPTS="$(find $IPTABLES_CUSTOM_DIR -maxdepth 1 -type f -name "*insert.sh" -print0 | xargs -0r)"
        [ -z "$CUSTOM_INSERT_SCRIPTS" ] || {
            for FILE in $CUSTOM_INSERT_SCRIPTS ; do
                echo -n "..Executing custom iptables insertion script $FILE"
                sh $FILE
                log_end_msg "$?"
            done
            }

        # Chain activation
        case "$IPTABLES_ACTIVATION" in
        '0')
            if [ "$VERBOSE" -eq 1 ] ; then
                echo "..Not activating chains."
            fi
            ;;
        '1'|'2')
            echo "..Activating chains:"
            # Don't send RELATED or ESTABLISHED packets to the pglcmd_* chains.
            case "$IPTABLES_ACTIVATION" in
            '1')
                CMD_STATE="-m conntrack ! --ctstate RELATED,ESTABLISHED"
                ;;
            '2')
                CMD_STATE=""
                ;;
            esac
            # Don't send "marked accept" packets to the pglcmd_* chains.
            # From there "marked" packets are sent back to the head of the chain again
            # (NF_REPEAT repeats the hook function). Thus "marked accept" packets traverse to
            # the rest of the iptables setup.
            # Problem: If another rule changes the MARK the packet will loop forever.
            CMD_MARK_ACCEPT="-m mark ! --mark $ACCEPT_MARK"

            # If INTERFACES is empty/not set, then set it to "all".
            INTERFACES=${INTERFACES:-all}

            # Send traffic of the specified interfaces to the pgl chains.
            for INTERFACE in $INTERFACES ; do
                for CHAIN in $CHAINS ; do
                    case $CHAIN in
                    INPUT)
                        PGL_CHAIN="$IPTABLES_IN"
                        ;;
                    OUTPUT)
                        PGL_CHAIN="$IPTABLES_OUT"
                        ;;
                    FORWARD)
                        PGL_CHAIN="$IPTABLES_FWD"
                        ;;
                    esac

                    # Activate iptables chain and remember iptables removal command.
                    # Remember the removal command before actually inserting, because one of the possible reasons for
                    # the iptables command to fail is that the rule already exists (for whatever reason).
                    if [ "$INTERFACE" = all ] ; then
                        echo  "....$CHAIN"
                        echo "iptables -D $CHAIN $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN" >> ${REMOVE_SCRIPT}.tmp &&
                        iptables -I $CHAIN $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN ||
                        fail_insert_iptables
                    else
                        echo  "....$CHAIN on $INTERFACE"
                        case $CHAIN in
                        INPUT)
                            echo "iptables -D $CHAIN -i $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN" >> ${REMOVE_SCRIPT}.tmp &&
                            iptables -I $CHAIN -i $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN ||
                            fail_insert_iptables
                            ;;
                        OUTPUT)
                            echo "iptables -D $CHAIN -o $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN" >> ${REMOVE_SCRIPT}.tmp &&
                            iptables -I $CHAIN -o $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN ||
                            fail_insert_iptables
                            ;;
                        FORWARD)
                            echo "iptables -D $CHAIN -i $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN" >> ${REMOVE_SCRIPT}.tmp &&
                            iptables -I $CHAIN -i $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN &&
                            echo "iptables -D $CHAIN -o $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN" >> ${REMOVE_SCRIPT}.tmp &&
                            iptables -I $CHAIN -o $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN ||
                            fail_insert_iptables
                            ;;
                        # Valid CHAINs was already tested above. No test needed here.
                        esac
                    fi
                done
            done
            echo "..Chains activated."
            # Build the REMOVE_SCRIPT
            # In REMOVE_SCRIPT are the flush&remove-chains commands (first inserted),
            # in REMOVE_SCRIPT.tmp the remove-the-activation-rules commands.
            # The way the script is built, this order is reversed:
            cat $REMOVE_SCRIPT >> ${REMOVE_SCRIPT}.tmp &&
                mv ${REMOVE_SCRIPT}.tmp $REMOVE_SCRIPT ||
                { echo "Error: Could not build the iptables remove script!" ; fail_insert_iptables ; }
            ;;
        esac
        echo "Iptables inserted."
        ;;
    '2')
        CUSTOM_INSERT_SCRIPTS="$(find $IPTABLES_CUSTOM_DIR -maxdepth 1 -type f -name "*insert.sh" -print0 | xargs -0r)"
        [ -z "$CUSTOM_INSERT_SCRIPTS" ] || {
            for FILE in $CUSTOM_INSERT_SCRIPTS ; do
                echo -n "  Executing custom iptables insertion script $FILE ..."
                sh $FILE && log_end_msg $? || fail_insert_iptables
                log_end_msg $?
            done
            }
        ;;
    esac
}

# Function that deletes the iptables rules
# iptables command errors are ignored, because removing an already removed rule
# causes an error, although this is no problem for us.
delete_iptables () {
    test_IPTABLES_VARS
    test_external iptables || {
        log_failure_msg "Error $E_XEXTERNAL: iptables not installed."
        exit $E_XEXTERNAL
        }
    echo "Deleting iptables ..."

    # Execute custom iptables remove scripts if configured
    if [ "$IPTABLES_SETTINGS" -gt 0 ] ; then
        # If custom iptables remove scripts exist, execute them:
        CUSTOM_REMOVE_SCRIPTS="$(find $IPTABLES_CUSTOM_DIR -maxdepth 1 -type f -name "*remove.sh" -print0 | xargs -0r)"
        [ -z "$CUSTOM_REMOVE_SCRIPTS" ] || {
            for FILE in $CUSTOM_REMOVE_SCRIPTS ; do
                echo -n "..Executing custom iptables remove script $FILE"
                sh $FILE
                log_end_msg $?
            done
            }
    fi
    if [ -f "$REMOVE_SCRIPT" ] ; then
        # Delete previously inserted iptables rules in any case. REMOVE_SCRIPT is created in insert_iptables
        echo -n "..Executing iptables remove script $REMOVE_SCRIPT"
        sh $REMOVE_SCRIPT
        log_end_msg $?
        # Remove REMOVE_SCRIPT in any case! It's not meant to be used several times.
        echo -n "..Removing iptables remove script $REMOVE_SCRIPT"
        rm $REMOVE_SCRIPT
        log_end_msg $?
    fi
    echo "Iptables deleted."
}

# md5sum of all relevant parts for building the MASTER_BLOCKLIST
set_md5sum () {
    SUM="$(
        echo $IP_REMOVE
        [ -f "$BLOCKLISTS_LIST" ] && md5sum $BLOCKLISTS_LIST
        [ -f "$MASTER_BLOCKLIST" ] && md5sum $MASTER_BLOCKLIST
        set_BLOCKLISTS_LOCAL
        for LIST in $BLOCKLISTS_LOCAL ; do
            [ -f "$LIST" ] && md5sum $LIST
        done
        )"
    MD5SUM="$(echo $SUM | md5sum | cut -c -32)"
}

# Set local allow- and blocklists variables.
# All files and links (except those which start with "#" or ".", or end in "~" )
# in the top-level of their directories are used.
# Spaces in listnames are not allowed.
set_BLOCKLISTS_LOCAL () {
    BLOCKLISTS_LOCAL=""
    [ -d "$LOCAL_BLOCKLIST_DIR" ] &&
    BLOCKLISTS_LOCAL="$(find -L $LOCAL_BLOCKLIST_DIR -maxdepth 1 -type f \
        ! -name "*~" \
        ! -name "#*" \
        ! -name ".*" |
        tr "\n" " ")"
}
set_LOCAL_ALLOWLISTS_IN () {
    LOCAL_ALLOWLISTS_IN=""
    [ -d "$LOCAL_ALLOWLISTS_IN_DIR" ] &&
    LOCAL_ALLOWLISTS_IN="$(find -L $LOCAL_ALLOWLISTS_IN_DIR -maxdepth 1 -type f \
        ! -name "*~" \
        ! -name "#*" \
        ! -name ".*" |
        tr "\n" " ")"
}
set_LOCAL_ALLOWLISTS_OUT () {
    LOCAL_ALLOWLISTS_OUT=""
    [ -d "$LOCAL_ALLOWLISTS_OUT_DIR" ] &&
    LOCAL_ALLOWLISTS_OUT="$(find -L $LOCAL_ALLOWLISTS_OUT_DIR -maxdepth 1 -type f \
        ! -name "*~" \
        ! -name "#*" \
        ! -name ".*" |
        tr "\n" " ")"
}
set_LOCAL_ALLOWLISTS_FWD () {
    LOCAL_ALLOWLISTS_FWD=""
    [ -d "$LOCAL_ALLOWLISTS_FWD_DIR" ] &&
    LOCAL_ALLOWLISTS_FWD="$(find -L $LOCAL_ALLOWLISTS_FWD_DIR -maxdepth 1 -type f \
        ! -name "*~" \
        ! -name "#*" \
        ! -name ".*" |
        tr "\n" " ")"
}

# Function that starts the watchdog
do_start_wd () {
    # Start pglcmd.wd.
    echo -n "Starting $(basename $WD_PATHNAME)"
    test_WD_PATHNAME
    test_WD_PID

    # Test WD_NICE setting.
    [ "$WD_NICE" -ge -20 ] && [ "$WD_NICE" -le 19 ] || {
        log_failure_msg " Error $E_CONFIG: Check the WD_NICE setting."
        exit $E_CONFIG
        }

    # Start pglcmd.wd in the background. Therefore no real check possible if this succeeded.
    if test_external start-stop-daemon ; then
        # Use start-stop-daemon
        # Start watchdog in the background with "-b"
        # Note: use -N for nice level, not -n as per LSB
        #start-stop-daemon -b -N $WD_NICE -p $WD_PID --exec $WD_PATHNAME --start --
        # Use -x and -S to avoid problems on synology
        start-stop-daemon -b -N $WD_NICE -p $WD_PID -x $WD_PATHNAME -S --
    else
        # LSB, start pglcmd.wd in the background with "&".
        start_daemon -n $WD_NICE -p $WD_PID $WD_PATHNAME &
    fi
    # TODO: kill -0 "$(pidofproc $WD_PATHNAME)" > /dev/null 2>&1
    RETVAL=$?
    log_end_msg $RETVAL
}

# Function that stops the watchdog
do_stop_wd () {
    # Stop pglcmd.wd
    echo -n "Stopping $(basename $WD_PATHNAME)"
    # Watchdog does not react to the TERM signal, while he´s sleeping.
    # Therefore send a KILL. The pidfile has to be removed manually then, see below!
    PID_OPT=""
    [ -z "$WD_PID" ] || PID_OPT="-p $WD_PID"
    killproc "$PID_OPT" "$WD_PATHNAME" -KILL

    # Verify that the watchdog is really not running.
    kill -0 "$(pidof $WD_PATHNAME)" > /dev/null 2>&1
    # If old process is not running, remember success and break.
    if [ "$?" -eq 0 ] ; then
        # Process is still running
        RETVAL=1
    else
        rm -f $WD_PID
        RETVAL=0
    fi

    log_end_msg $RETVAL
}

# Function that starts daemon and watchdog
do_start () {
    test_DAEMON
    # Check if daemon is already running
    status_of_proc $DAEMON $NAME > /dev/null 2>&1
    RETVAL=$?
    case "$RETVAL" in
        0)  # Daemon is running
            log_success_msg "$NAME is already running, doing nothing."
            ;;
        3)  # Daemon is not running.

            # Build blocklist if necessary to make sure pglcmd's settings are taken.
            # Force to build it, if started with force-restart.
            [ ! "$CMD_OPTION" = force-restart ] &&
                [ -f "$MD5SUM_FILE" ] &&
                set_md5sum &&
                [ "$MD5SUM" = "$(cat $MD5SUM_FILE)" ] ||
                build_blocklist

            test_IPTABLES_TARGET
            test_IPTABLES_VARS
            test_LOG_SYSLOG
            test_PIDFILE

            # Load kernel modules after checking if they are already loaded / were compiled in the kernel directly.
            # Note 1: I (jre) have not seen documentation how this works. E.g. loading (modprobe) a module does
            #         not give the specified entries in /proc/net. But once pgld was started they are there.
            # Note 2: On a first glance some modules might be loaded conditional on some configuration. I decided
            #         against that to allow for e.g. custom iptables rules.

            # TODO: iptable_filter
            # TODO: ip_tables
            # TODO: nfnetlink
            # TODO: nfnetlink_queue
            # TODO: x_tables

            # xt_NFQUEUE
            case "$IPTABLES_TARGET" in
                NFQUEUE)
                    [ -f /proc/net/ip_tables_targets ] && grep -q NFQUEUE /proc/net/ip_tables_targets ||
                        modprobe -q xt_NFQUEUE ||
                        modprobe -q ipt_NFQUEUE || {
                        log_failure_msg "Error $E_XEXTERNAL: Could not load kernel module xt_NFQUEUE, not starting $NAME!"
                        exit $E_XEXTERNAL
                        }
                    ;;
                QUEUE)
                    [ -f /proc/net/ip_queue ] ||
                        modprobe -q ip_queue || {
                        log_failure_msg "Error $E_XEXTERNAL: Could not load kernel module ip_queue, not starting $NAME!"
                        exit $E_XEXTERNAL
                        }
                    ;;
            esac

            # TODO: xt_tcpudp
                # /proc/net/ip_tables_matches:
                # udplite
                # udp
                # tcp

            # xt_mark
            [ -f /proc/net/ip_tables_matches ] && grep -q mark /proc/net/ip_tables_matches ||
                modprobe -q xt_mark ||
                modprobe -q ipt_mark ||
                {
                    log_failure_msg "Error $E_XEXTERNAL: Could not load kernel module xt_mark, not starting $NAME!"
                    log_failure_msg "Use a kernel with netfilter MARK support."
                    exit $E_XEXTERNAL
                }

            # ipt_REJECT
            if [ "$REJECT_OUT" = REJECT ] || [ "$REJECT_FWD" = REJECT ] || [ "$REJECT_IN" = REJECT ] ; then
                [ -f /proc/net/ip_tables_targets ] && grep -q REJECT /proc/net/ip_tables_targets ||
                modprobe -q xt_REJECT ||
                modprobe -q ipt_REJECT || {
                log_failure_msg "Error $E_XEXTERNAL: Could not load kernel module ipt_REJECT, not starting ${NAME}."
                log_failure_msg "Use a kernel with netfilter REJECT support or configure $(basename $0)"
                log_failure_msg "to DROP instead of REJECT blocked packets."
                exit $E_XEXTERNAL
                }
            fi

            # xt_conntrack
            # TODO: nf_conntrack
            # TODO: nf_conntrack_ipv4
            # TODO: nf_defrag_ipv4
            [ -f /proc/net/ip_tables_matches ] && grep -q conntrack /proc/net/ip_tables_matches ||
                modprobe -q xt_conntrack ||
                modprobe -q ipt_conntrack ||
                if [ "$IPTABLES_ACTIVATION" = 1 ] ; then
                    log_failure_msg "Error $E_XEXTERNAL: Could not load kernel module xt_conntrack, not starting $NAME!"
                    log_failure_msg "Use a kernel with netfilter CONNTRACK support or reconfigure $(basename $0)"
                    log_failure_msg "to check all traffic (not only NEW) traffic (option IPTABLES_ACTIVATION)"
                    log_failure_msg "(not recommended due to excess cpu usage)."
                    exit $E_XEXTERNAL
                else
                    log_warning_msg "Warning: Could not load kernel module xt_conntrack, continuing anyway."
                fi


            # Transition 2016-01-25: multiple allowlists

            # Step 1: Add old allowlists ALLOW_* to LOCAL_ALLOWLISTS_*_DIR/pgl.p2p
            # and disable them in CMD_CONF.
            # ALLOW_IN
            if [ -n "$ALLOW_IN" ] && [ -f "$ALLOW_IN" ] ; then
                echo "Allowlists for incoming connections are now in ${LOCAL_ALLOWLISTS_IN_DIR}/."
                echo -n "Adding old allowlist $ALLOW_IN to ${LOCAL_ALLOWLISTS_IN_DIR}/pgl.p2p"
                # Add a newline at end of pgl.p2p if it was missing.
                [ ! -f "${LOCAL_ALLOWLISTS_IN_DIR}/pgl.p2p" ] ||
                    sed -i -e '$a\' "${LOCAL_ALLOWLISTS_IN_DIR}/pgl.p2p"
                mkdir -p ${LOCAL_ALLOWLISTS_IN_DIR} &&
                    cat "$ALLOW_IN" >> "${LOCAL_ALLOWLISTS_IN_DIR}/pgl.p2p"
                [ ! -f "$CMD_CONF" ] ||
                    sed -i "s|^[[:space:]]*\(ALLOW_IN=.*\)|# $(date -I) superseded by LOCAL_ALLOWLISTS_IN_DIR: \1|g" "$CMD_CONF"
                echo "."
            elif [ -f "$CMD_CONF" ] &&  grep -vq "^[[:space:]]*ALLOW_IN=" "$CMD_CONF" && [ -f "${CONFDIR}/allow.p2p" ] ; then
                # ALLOW_IN was not set in CMD_CONF, transition the old default allowlist.
                echo "Allowlists for incoming connections are now in ${LOCAL_ALLOWLISTS_IN_DIR}/."
                echo -n "Adding old allowlist "${CONFDIR}/allow.p2p" to ${LOCAL_ALLOWLISTS_IN_DIR}/pgl.p2p"
                # Add a newline at end of pgl.p2p if it was missing.
                [ ! -f "${LOCAL_ALLOWLISTS_IN_DIR}/pgl.p2p" ] ||
                    sed -i -e '$a\' "${LOCAL_ALLOWLISTS_IN_DIR}/pgl.p2p"
                mkdir -p ${LOCAL_ALLOWLISTS_IN_DIR} &&
                    cat "${CONFDIR}/allow.p2p" >> "${LOCAL_ALLOWLISTS_IN_DIR}/pgl.p2p"
                sed -i "s|^[[:space:]]*\(ALLOW_IN=.*\)|# $(date -I) superseded by LOCAL_ALLOWLISTS_IN_DIR: \1|g" "$CMD_CONF"
                echo "."
            elif [ -f "$CMD_CONF" ] && grep -q "^[[:space:]]*ALLOW_IN=" "$CMD_CONF" ; then
                # Finally disable any remaining setting (ALLOW_IN="") from CMD_CONF
                sed -i "s|^[[:space:]]*\(ALLOW_IN=.*\)|# $(date -I) superseded by LOCAL_ALLOWLISTS_IN_DIR: \1|g" "$CMD_CONF"
            fi
            # ALLOW_OUT
            if [ -n "$ALLOW_OUT" ] && [ -f "$ALLOW_OUT" ] ; then
                echo "Allowlists for outgoing connections are now in ${LOCAL_ALLOWLISTS_OUT_DIR}/."
                echo -n "Adding old allowlist $ALLOW_OUT to ${LOCAL_ALLOWLISTS_OUT_DIR}/pgl.p2p"
                # Add a newline at end of pgl.p2p if it was missing.
                [ ! -f "${LOCAL_ALLOWLISTS_OUT_DIR}/pgl.p2p" ] ||
                    sed -i -e '$a\' "${LOCAL_ALLOWLISTS_OUT_DIR}/pgl.p2p"
                mkdir -p ${LOCAL_ALLOWLISTS_OUT_DIR} &&
                    cat "$ALLOW_OUT" >> "${LOCAL_ALLOWLISTS_OUT_DIR}/pgl.p2p"
                [ ! -f "$CMD_CONF" ] ||
                    sed -i "s|^[[:space:]]*\(ALLOW_OUT=.*\)|# $(date -I) superseded by LOCAL_ALLOWLISTS_OUT_DIR: \1|g" "$CMD_CONF"
                echo "."
            elif [ -f "$CMD_CONF" ] && grep -vq "^[[:space:]]*ALLOW_OUT=" "$CMD_CONF" && [ -f "${CONFDIR}/allow.p2p" ] ; then
                # ALLOW_OUT was not (un-)set in CMD_CONF, transition the old default allowlist.
                echo "Allowlists for outgoing connections are now in ${LOCAL_ALLOWLISTS_OUT_DIR}/."
                echo -n "Adding old allowlist "${CONFDIR}/allow.p2p" to ${LOCAL_ALLOWLISTS_OUT_DIR}/pgl.p2p"
                # Add a newline at end of pgl.p2p if it was missing.
                [ ! -f "${LOCAL_ALLOWLISTS_OUT_DIR}/pgl.p2p" ] ||
                    sed -i -e '$a\' "${LOCAL_ALLOWLISTS_OUT_DIR}/pgl.p2p"
                mkdir -p ${LOCAL_ALLOWLISTS_OUT_DIR} &&
                    cat "${CONFDIR}/allow.p2p" >> "${LOCAL_ALLOWLISTS_OUT_DIR}/pgl.p2p"
                sed -i "s|^[[:space:]]*\(ALLOW_OUT=.*\)|# $(date -I) superseded by LOCAL_ALLOWLISTS_OUT_DIR: \1|g" "$CMD_CONF"
                echo "."
            elif [ -f "$CMD_CONF" ] && grep -q "^[[:space:]]*ALLOW_OUT=" "$CMD_CONF" ; then
                # Finally disable any remaining setting (ALLOW_OUT="") from CMD_CONF
                sed -i "s|^[[:space:]]*\(ALLOW_OUT=.*\)|# $(date -I) superseded by LOCAL_ALLOWLISTS_OUT_DIR: \1|g" "$CMD_CONF"
            fi
            # ALLOW_FWD
            if [ -n "$ALLOW_FWD" ] && [ -f "$ALLOW_FWD" ] ; then
                echo "Allowlists for forwarded connections are now in ${LOCAL_ALLOWLISTS_FWD_DIR}/."
                echo -n "Adding old allowlist $ALLOW_FWD to ${LOCAL_ALLOWLISTS_FWD_DIR}/pgl.p2p"
                # Add a newline at end of pgl.p2p if it was missing.
                [ ! -f "${LOCAL_ALLOWLISTS_FWD_DIR}/pgl.p2p" ] ||
                    sed -i -e '$a\' "${LOCAL_ALLOWLISTS_FWD_DIR}/pgl.p2p"
                mkdir -p ${LOCAL_ALLOWLISTS_FWD_DIR} &&
                    cat "$ALLOW_FWD" >> "${LOCAL_ALLOWLISTS_FWD_DIR}/pgl.p2p"
                [ ! -f "$CMD_CONF" ] ||
                    sed -i "s|^[[:space:]]*\(ALLOW_FWD=.*\)|# $(date -I) superseded by LOCAL_ALLOWLISTS_FWD_DIR: \1|g" "$CMD_CONF"
                echo "."
            elif [ -f "$CMD_CONF" ] && grep -q "^[[:space:]]*ALLOW_FWD=" "$CMD_CONF" ; then
                # Finally disable any remaining setting (ALLOW_FWD="") from CMD_CONF
                sed -i "s|^[[:space:]]*\(ALLOW_FWD=.*\)|# $(date -I) superseded by LOCAL_ALLOWLISTS_FWD_DIR: \1|g" "$CMD_CONF"
            fi

            # Step 2: Rename old allowlists.
            # Note: Users might have used the same filepath for several connection directions,
            # so we couldn't do this above.
            if [ -n "${ALLOW_IN}" ] && [ -f "${ALLOW_IN}" ] ; then
                mv "${ALLOW_IN}" "${ALLOW_IN}.orig.$(date -Iseconds)"
            fi
            if [ -n "${ALLOW_OUT}" ] && [ -f "${ALLOW_OUT}" ] ; then
                mv "${ALLOW_OUT}" "${ALLOW_OUT}.orig.$(date -Iseconds)"
            fi
            if [ -n "${ALLOW_FWD}" ] && [ -f "${ALLOW_FWD}" ] ; then
                mv "${ALLOW_FWD}" "${ALLOW_FWD}.orig.$(date -Iseconds)"
            fi
            if [ -f "${CONFDIR}/allow.p2p" ] ; then
                mv "${CONFDIR}/allow.p2p" "${CONFDIR}/allow.p2p.orig.$(date -Iseconds)"
            fi

            # Step 3: Add contents of WHITE_IP_ to LOCAL_ALLOWLISTS_*_DIR/pgl.p2p
            # WHITE_IP_IN
            if [ -n "$WHITE_IP_IN" ] ; then
                echo "Usage of WHITE_IP_IN is superseded by using allowlists in ${LOCAL_ALLOWLISTS_IN_DIR}."
                echo -n "Adding old WHITE_IP_IN settings to ${LOCAL_ALLOWLISTS_IN_DIR}/pgl.p2p"
                # Add a newline at end of pgl.p2p if it was missing.
                [ ! -f "${LOCAL_ALLOWLISTS_IN_DIR}/pgl.p2p" ] ||
                    sed -i -e '$a\' "${LOCAL_ALLOWLISTS_IN_DIR}/pgl.p2p"
                mkdir -p ${LOCAL_ALLOWLISTS_IN_DIR}
                # Add every item as new line to the allowlist.
                for IP in $WHITE_IP_IN ; do
                    echo "$(date -I) moved from WHITE_IP_IN:$IP" >> "${LOCAL_ALLOWLISTS_IN_DIR}/pgl.p2p"
                done
                # Comment the variable in CMD_CONF (the variable has been removed from .defaults)
                sed -i "s|^[[:space:]]*\(WHITE_IP_IN=.*\)|# $(date -I) moved to ${LOCAL_ALLOWLISTS_IN_DIR}/pgl.p2p: \1|g" "$CMD_CONF"
                echo "."
            fi
            # WHITE_IP_OUT
            if [ -n "$WHITE_IP_OUT" ] ; then
                echo "Usage of WHITE_IP_OUT is superseded by using allowlists in ${LOCAL_ALLOWLISTS_OUT_DIR}."
                echo -n "Adding old WHITE_IP_OUT settings to ${LOCAL_ALLOWLISTS_OUT_DIR}/pgl.p2p"
                # Add a newline at end of pgl.p2p if it was missing.
                [ ! -f "${LOCAL_ALLOWLISTS_OUT_DIR}/pgl.p2p" ] ||
                    sed -i -e '$a\' "${LOCAL_ALLOWLISTS_OUT_DIR}/pgl.p2p"
                mkdir -p ${LOCAL_ALLOWLISTS_OUT_DIR}
                # Add every item as new line to the allowlist.
                for IP in $WHITE_IP_OUT ; do
                    echo "$(date -I) moved from WHITE_IP_OUT:$IP" >> "${LOCAL_ALLOWLISTS_OUT_DIR}/pgl.p2p"
                done
                # Comment the variable in CMD_CONF (the variable has been removed from .defaults)
                sed -i "s|^[[:space:]]*\(WHITE_IP_OUT=.*\)|# $(date -I) moved to ${LOCAL_ALLOWLISTS_OUT_DIR}/pgl.p2p: \1|g" "$CMD_CONF"
                echo "."
            fi
            # WHITE_IP_FWD
            if [ -n "$WHITE_IP_FWD" ] ; then
                echo "Usage of WHITE_IP_FWD is superseded by using allowlists in ${LOCAL_ALLOWLISTS_FWD_DIR}."
                echo -n "Adding old WHITE_IP_FWD settings to ${LOCAL_ALLOWLISTS_FWD_DIR}/pgl.p2p"
                # Add a newline at end of pgl.p2p if it was missing.
                [ ! -f "${LOCAL_ALLOWLISTS_FWD_DIR}/pgl.p2p" ] ||
                    sed -i -e '$a\' "${LOCAL_ALLOWLISTS_FWD_DIR}/pgl.p2p"
                mkdir -p ${LOCAL_ALLOWLISTS_FWD_DIR}
                # Add every item as new line to the allowlist.
                for IP in $WHITE_IP_FWD ; do
                    echo "$(date -I) moved from WHITE_IP_FWD:$IP" >> "${LOCAL_ALLOWLISTS_FWD_DIR}/pgl.p2p"
                done
                # Comment the variable in CMD_CONF (the variable has been removed from .defaults)
                sed -i "s|^[[:space:]]*\(WHITE_IP_FWD=.*\)|# $(date -I) moved to ${LOCAL_ALLOWLISTS_FWD_DIR}/pgl.p2p: \1|g" "$CMD_CONF"
                echo "."
            fi

            # Execute old REMOVE_SCRIPT if it still exists for any reason, because we may run into troubles
            # if there are still old iptables.
            if [ -f "$REMOVE_SCRIPT" ] ; then
                echo -n "Old iptables remove script $REMOVE_SCRIPT still exists! Executing"
                sh $REMOVE_SCRIPT
                echo -n " and removing it"
                rm $REMOVE_SCRIPT
                log_end_msg $?
            fi

            insert_iptables

            echo -n "Starting $NAME"

            # Set the log to syslog option
            if [ "$LOG_SYSLOG" -eq 1 ] ; then
                LOG_SYSLOG_OPT="-s"
            else
                LOG_SYSLOG_OPT=""
            fi

            # Set the log to logfile option
            if [ "$LOG_LOGFILE" -eq 1 ] ; then
                LOG_LOGFILE_OPT="-l $DAEMON_LOG"
            else
                LOG_LOGFILE_OPT=""
            fi

            # Set the kernel queue maximum length option
            if [ ! -n "$NFQUEUE_MAXLEN" ] ; then
                true
            elif [ "$NFQUEUE_MAXLEN" -ge 1 ] && [ "$NFQUEUE_MAXLEN" -le 4294967295 ] ; then
                NFQUEUE_MAXLEN_OPT="-Q $NFQUEUE_MAXLEN"
            else
                echo "\nWARN: NFQUEUE_MAXLEN $NFQUEUE_MAXLEN has to be in range 1 - 4294967295. Ignoring."
            fi

            # Set the options for marking matched packets
            REJECT_OPT="-r $REJECT_MARK"

            # Set the options for marking not matched packets
            ACCEPT_OPT="-a $ACCEPT_MARK"

            # Set the NFQUEUE number only if NFQUEUE and not QUEUE is used
            case "$IPTABLES_TARGET" in
                NFQUEUE)
                    NFQUEUE_NUMBER_OPT="-q $NFQUEUE_NUMBER"
                    ;;
                QUEUE)
                    NFQUEUE_NUMBER_OPT=""
                    ;;
            esac

            # Set D-Bus
            if [ "$DBUS" -eq 1 ]
            then
                DBUS_OPT="-d"
            else
                DBUS_OPT=""
            fi

            # Set the options the daemon is started with
            DAEMON_OPTS="$LOG_SYSLOG_OPT $LOG_LOGFILE_OPT $DBUS_OPT -p $PIDFILE $NFQUEUE_NUMBER_OPT $NFQUEUE_MAXLEN_OPT $REJECT_OPT $ACCEPT_OPT $MASTER_BLOCKLIST"

            # Test NICE_LEVEL setting.
            [ "$NICE_LEVEL" -ge -20 ] && [ "$NICE_LEVEL" -le 19 ] || {
                log_failure_msg " Error $E_CONFIG: Check the NICE_LEVEL setting."
                exit $E_CONFIG
                }

            # Start daemon
            start_daemon -n $NICE_LEVEL -p $PIDFILE $DAEMON $DAEMON_OPTS
            RETVAL=$?
            log_end_msg $RETVAL

            if [ "$RETVAL" = 0 ] ; then
                if [ "$WD" = 1 ] ; then
                    # Start pglcmd.wd.
                    do_start_wd
                fi
            else
                # Remove iptables again, since starting failed.
                # Save the retval (although currently delete_iptables doesn't use this variable).
                SAVE_RETVAL=$RETVAL
                delete_iptables
                RETVAL=$SAVE_RETVAL
            fi
            ;;
        # Problematic daemon status. Be verbose and exit!
        *)
            echo "Problematic daemon status: $RETVAL"
            status_of_proc $DAEMON $NAME
            exit $?
            ;;
    esac
}

do_stop_quick () {
    STOP_QUICK=1
    do_stop
}

# Function that stops daemon (but not watchdog)
do_stop () {
    # Email stats, except if we are on system shutdown.
    [ "$STOP_QUICK" ] || email_stats
    # Remove iptables rules/chains
    delete_iptables
    # As per LSB don't test if daemon is installed on stop!
    echo -n "Stopping $NAME"
    PID_OPT=""
    [ -z "$PIDFILE" ] || PID_OPT="-p $PIDFILE"
    killproc "$PID_OPT" "$DAEMON"

    # Verify that the daemon is really not running. This may take some
    # time, even after the killproc ended successfully.
    # Normally killproc should take care of this.
    # Otherwise restarting pgld fails, because it was restarted too early.
    # This also fixes broken lsb init-functions (e.g. Ubuntu hardy), that give
    # the wrong exit code.
    COUNT=0
    # Wait up to 20 seconds
    while [ "$COUNT" -lt 20 ] ; do
        # Verify that the daemon is really not running.
        kill -0 "$(pidof $DAEMON)" > /dev/null 2>&1
        # If old process is not running, remember success and break.
        if [ "$?" -eq 0 ] ; then
            # Process is still running
            RETVAL=1
            sleep 1
            COUNT=$(($COUNT+1))
        else
            rm -f $PIDFILE
            RETVAL=0
            break
        fi
    done
    # If pidfile still exists (stop failed), force pgld to quit.
    [ ! -f "$PIDFILE" ] || { kill -9 "$(pidof $DAEMON)" && rm -f $PIDFILE ; }
    RETVAL=$?

    log_end_msg $RETVAL
}

# Function that restarts daemon
do_restart () {
    do_stop
    do_start
}

# Function that rebuilds master blocklist and reloads daemon
do_reload () {
    test_DAEMON
    # Check if daemon is running
    status_of_proc $DAEMON $NAME > /dev/null 2>&1
    RETVAL=$?
    case "$RETVAL" in
        0)  # Daemon is running
            # Build blocklist if necessary to make sure pglcmd's settings are taken.
            # Force to build it, if started with force-reload.
            [ ! "$CMD_OPTION" = force-reload ] &&
                [ -f "$MD5SUM_FILE" ] && set_md5sum && [ "$MD5SUM" = "$(cat $MD5SUM_FILE)" ] ||
                build_blocklist
            echo -n "Reloading $NAME"
            kill -s HUP "$(pidofproc $DAEMON)"
            RETVAL=$?
            log_end_msg $RETVAL
            ;;
        3)  # Daemon is not running
            echo "$NAME is not running, doing nothing."
            RETVAL=0
            ;;
        # Problematic daemon status. Be verbose and exit!
        *)
            echo "Problematic daemon status: $RETVAL"
            status_of_proc $DAEMON $NAME
            exit $?
            ;;
    esac
}

# Read the non-comment|not-empty lines from BLOCKLISTS_LIST.
# Ignore all entries after # (comments).
set_LISTS_URL () {
    if [ -f "$BLOCKLISTS_LIST" ] ; then
        LISTS_URL="$(grep -Ev "^[[:space:]]*#|^[[:space:]]*$" $BLOCKLISTS_LIST | sed "s|#.*$||g")"
        [ $? -eq 0 ] ||
            { log_failure_msg "Error: set_LISTS_URL exited with $?" ; exit 1 ; }
    else
        LISTS_URL=""
    fi
}

# This function depends on LIST:
LIST_URL2LIST_NAME () {
    # Set LIST_URL depending on LIST
    # Since IFS now is standard IFS, separate words (not the complete lines from
    # blocklists.list) are used for LIST.
    # Assuming remote blocklists (supported through wget) for all blocklists in blocklists.list:
    LIST_URL="$( echo $LIST | sed -r "s|http://||;s|https://||;s|ftp://||" )"

    # Translate LIST_URL to human readable/debconf LIST_NAME.
    # Several LIST_URL may resolve to the same LIST_NAME, if alternative URLs are known for the same list.
    case $LIST_URL in
    list.iblocklist.com/?list=*)
        # Strip iblocklist.com prefix and extensions like "&fileformat=p2p&archiveformat=gz"
        LIST_URL_TRUNK="$( echo $LIST_URL | sed "s|list.iblocklist.com/?list=||;s|\&.*||" )"
        # Grep LIST_URL_TRUNK from lists.xml. If this file is missing, try to download it.
        if ( [ -f ${BLOCKLISTS_DIR}/lists.xml ] ||
        ( test_net && [ -f ${BLOCKLISTS_DIR}/lists.xml ] )
        ) &&
        grep -q "<list>${LIST_URL_TRUNK}</list>" ${BLOCKLISTS_DIR}/lists.xml ; then
            LIST_AUTHOR="$( grep -A 2 "<list>${LIST_URL_TRUNK}</list>" ${BLOCKLISTS_DIR}/lists.xml | \
                grep -o "<author>.*</author>" | \
                sed "s|<author>\(.*\)</author>|\1|" )"
            LIST_NAME1="$( grep -A 2 "<list>${LIST_URL_TRUNK}</list>" ${BLOCKLISTS_DIR}/lists.xml | \
                grep -o "<name>.*</name>" | \
                sed "s|<name>\(.*\)</name>|\1|" )"
        else
            LIST_AUTHOR="unknown_iblocklist"
            LIST_NAME1="$LIST_URL_TRUNK"
        fi
        LIST_NAME=${LIST_AUTHOR}_${LIST_NAME1}
        ;;
    list.iblocklist.com/lists/*/*)
        # Strip iblocklist.com prefix and extensions like "&fileformat=p2p&archiveformat=gz"
        LIST_URL_TRUNK="$( echo $LIST_URL | sed "s|list.iblocklist.com/lists/||;s|\&.*||" )"
        LIST_AUTHOR="$( echo $LIST_URL_TRUNK  | sed "s|\(.*\)/\(.*\)|\1|" )"
        LIST_NAME1="$( echo $LIST_URL_TRUNK | sed "s|\(.*\)/\(.*\)|\2|" )"
        LIST_NAME=${LIST_AUTHOR}_${LIST_NAME1}
        # Fix inconsistent iblocklist names:
        if [ "$LIST_NAME" = bluetack_level-1 ] ; then
            LIST_NAME="bluetack_level1"
        elif [ "$LIST_NAME" = bluetack_level-2 ] ; then
            LIST_NAME="bluetack_level2"
        elif [ "$LIST_NAME" = bluetack_level-3 ] ; then
            LIST_NAME="bluetack_level3"
        fi
        ;;
    *)
        # Otherwise, use LIST_URL.
        LIST_NAME="$LIST_URL"
        ;;
    esac
    # Replace problematic letters, make everything lowercase
    LIST_NAME="$( echo $LIST_NAME | sed "s|.*://|_|;s|/|_|g;s/?/_/g;s/ /_/g;s/\(.\)/\L\1/g" )"
}

# Get blocklist.
get_blocklist () {
    # Depends on LIST being set.
    [ -n "$LIST" ] || {
        echo "Error $E_BLOCKLIST: get_blocklist: internal error, LIST is not set or BLOCKLISTS_LIST not existant!"
        exit $E_BLOCKLIST
        }
    test_BLOCKLISTS_DIR
    # This function depends on LIST:
    LIST_URL2LIST_NAME

    # Set blocklist directory name.
    BLOCKLIST_DIR="$BLOCKLISTS_DIR/$LIST_NAME"
    # Gives the name of the blocklist downloaded by wget. Reset the value here
    # and set it later in the script:
    BLOCKLIST_DOWNLOAD=""
    # Gives the name of successfully downloaded files:
    BLOCKLIST_DOWNLOADED="$BLOCKLIST_DIR/downloaded/$LIST_NAME"
    # BLOCKLIST_DOWNLOADED is extracted to this file
    BLOCKLIST_EXTRACTED="$BLOCKLIST_DIR/extracted/$LIST_NAME"

    echo -n "Updating $LIST_NAME... "

    # Assuming remote blocklists (supported through wget) for all blocklists in blocklists.list:
    # Create necessary directories if missing:
    [ -d "$BLOCKLIST_DIR/download" ] ||
        mkdir -p "$BLOCKLIST_DIR/download" ||
        { log_failure_msg " Error: mkdir -p exited with $?" ; exit 1 ; }

    cd "$BLOCKLIST_DIR/download" ||
        { log_failure_msg " Error: cd exited with $?" ; exit 1 ; }

    # Create necessary directories if missing:
    [ -d "$(dirname $BLOCKLIST_DOWNLOADED)" ] ||
        mkdir -p "$(dirname $BLOCKLIST_DOWNLOADED)" ||
        { log_failure_msg "Error: mkdir -p exited with $?" ; exit 1 ; }

    # Download blocklists with timestamping. If this fails remove
    # the old blocklist (which might be a corrupted file)
    # and try again without timestamping:
    test_external wget || {
        log_failure_msg "Error $E_XEXTERNAL: wget not installed."
        exit $E_XEXTERNAL
        }
    # If 7z is not available, change user agent to pglcmd_x7z,
    # so that iblocklist.com knows we are not capable of 7z.
    test_external 7zr ||
        test_external 7za ||
        test_external 7z ||
        test_external p7zip ||
        WGET_OPTS="$(echo $WGET_OPTS |
            sed "s|--user-agent=${CMD_NAME}/${VERSION}|--user-agent=${CMD_NAME}_x7z/${VERSION}|")"
    $WGET_OPTS -N "$LIST_URL"
    WGET_RET=$?
    case "$WGET_RET" in
        0)
            ;;
        403)
            echo -n "... Access denied!"
            rm -Rf $BLOCKLIST_DIR/download/* ||
                { log_failure_msg " Error: rm exited with $?" ; exit 1 ; }
            ;;
        *)
            echo -n "... failed!"
            rm -Rf $BLOCKLIST_DIR/download/* ||
                { log_failure_msg " Error: rm exited with $?" ; exit 1 ; }
            echo -n " Trying without timestamping ..."
            $WGET_OPTS "$LIST_URL"
            WGET_RET=$?
            ;;
    esac

    cd / ||
        { log_failure_msg " Error: cd exited with $?" ; exit 1 ; }

    # Get the name of the downloaded blocklist: BLOCKLIST_DOWNLOAD
    # Take the newest file, in case there are several files in the folder.
    # There may be several files from different URLs for the same LIST_NAME
    # If the directory is empty the variable will stay empty, too.
    ls $BLOCKLIST_DIR/download/* > /dev/null 2>&1 &&
        BLOCKLIST_DOWNLOAD="$BLOCKLIST_DIR/download/$(ls -1t $BLOCKLIST_DIR/download/ | head -n 1)"

    # Download was not successful, access forbidden
    if [ "$WGET_RET" -eq 403 ] ; then
        if [ -f "$BLOCKLIST_DOWNLOADED" ] ; then
            echo " forbidden! Using old blocklist."
            UPDATE_403="$UPDATE_403 $UPDATE_403 (last modified: $(stat --format=%y $BLOCKLIST_DOWNLOADED | head -c 16));"
        else
            log_failure_msg " Error $E_BLOCKLIST: $LIST_NAME access forbidden. Aborting!"
            log_failure_msg "Check your entry $LIST_URL in $BLOCKLISTS_LIST."
            log_failure_msg "To fix this manually download $LIST_URL and save it as $BLOCKLIST_DOWNLOADED"
            exit $E_BLOCKLIST
        fi
    # Download was not successful
    elif [ "$WGET_RET" -ne 0 ] ; then
        if [ -f "$BLOCKLIST_DOWNLOADED" ] ; then
            echo " failed! Using old blocklist."
            UPDATE_FAIL="$UPDATE_FAIL $LIST_NAME (last modified: $(stat --format=%y $BLOCKLIST_DOWNLOADED | head -c 16));"
        else
            log_failure_msg " Error $E_BLOCKLIST: $LIST_NAME not available. Aborting!"
            log_failure_msg "To fix this manually download $LIST_URL and save it as $BLOCKLIST_DOWNLOADED"
            exit $E_BLOCKLIST
        fi
    # Download was successful ($WGET_RET = 0):
    # This should not happen, just for debugging:
    elif [ -z "$BLOCKLIST_DOWNLOAD" ] ; then
        log_failure_msg " Error: $LIST_URL was downloaded successfully but BLOCKLIST_DOWNLOAD is empty! Strange, aborting!"
        exit 1
    # This should not happen, just for debugging:
    elif [ ! -f "$BLOCKLIST_DOWNLOAD" ] ; then
        log_failure_msg " Error: $LIST_URL was downloaded successfully but $BLOCKLIST_DOWNLOAD doesn't exist! Strange, aborting!"
        exit 1
    # Download was successful, old blocklist is not available or older than the new one:
    elif [ ! -f "$BLOCKLIST_DOWNLOADED" ] || [ "$BLOCKLIST_DOWNLOAD" -nt "$BLOCKLIST_DOWNLOADED" ] ; then
        cp -f --preserve=timestamps $BLOCKLIST_DOWNLOAD $BLOCKLIST_DOWNLOADED &&
            echo "done." ||
            { log_failure_msg " Error: cp exited with $?"; exit 1 ; }
        [ -f "$BLOCKLIST_DOWNLOADED" ] &&
            UPDATE_SUCCESS="$UPDATE_SUCCESS $LIST_NAME (last modified: $(stat --format=%y $BLOCKLIST_DOWNLOADED | head -c 16));" ||
            { log_failure_msg " Error: $LIST_URL exists, but $BLOCKLIST_DOWNLOADED doesn't exist! Strange, aborting!" ; exit 1 ; }
    # Download was successful, blocklist is not newer than the old one:
    else
        echo ". No update available."
        [ -f "$BLOCKLIST_DOWNLOADED" ] &&
            UPDATE_SUCCESS_NA="$UPDATE_SUCCESS_NA $LIST_NAME (last modified: $(stat --format=%y $BLOCKLIST_DOWNLOADED | head -c 16));" ||
            { log_failure_msg " Error: $LIST_URL exists, but $BLOCKLIST_DOWNLOADED doesn't exist! Strange, aborting!" ; exit 1 ; }
    fi

    extract_blocklist
}

# Depends on LIST_NAME, BLOCKLIST_DOWNLOADED and BLOCKLIST_EXTRACTED
extract_blocklist () {
    # Unpack the lists
    echo -n "Extracting $LIST_NAME, "

    # Create necessary directories if missing:
    [ -d "$(dirname $BLOCKLIST_EXTRACTED)" ] ||
        mkdir -p "$(dirname $BLOCKLIST_EXTRACTED)" ||
        { log_failure_msg " Error: mkdir -p exited with $?" ; exit 1 ; }

    # This should not happen, just for debugging:
    [ -f "$BLOCKLIST_DOWNLOADED" ] || {
        log_failure_msg " D'oh, why does $BLOCKLIST_DOWNLOADED not exist? Strange, aborting!" ; exit 1 ; }

    # General: To analyze the file header check
    # http://mark0.net/hexdump.html and get a list of TrID file type / file
    # extension definitions from http://mark0.net/soft-trid-deflist.html
    #
    # Using bytes with hexadecimal value HH:
    # $'\xHH' is a bashism.
    # "$(printf '\xHH')" doesn't work at least for the dash builtin printf, so
    # use: "$(/usr/bin/printf '\xHH')"

    # Read the first six (length of the 7z header) bytes of the packed
    # blocklist:
    case "$(head -c 6 $BLOCKLIST_DOWNLOADED)" in
        # 7z packed file
        "$(/usr/bin/printf '\x37\x7A\xBC\xAF\x27\x1C')")
            echo -n "detected 7z... "
            { test_external 7zr && EXTRACT_CMD='7zr x "$BLOCKLIST_DOWNLOADED" -so > "${BLOCKLIST_EXTRACTED}.tmp"' ; } ||
            { test_external 7za && EXTRACT_CMD='7za x "$BLOCKLIST_DOWNLOADED" -so > "${BLOCKLIST_EXTRACTED}.tmp"' ; } ||
            { test_external 7z && EXTRACT_CMD='7z x "$BLOCKLIST_DOWNLOADED" -so > "${BLOCKLIST_EXTRACTED}.tmp"' ; } ||
            { test_external p7zip && EXTRACT_CMD="p7zip -d < $BLOCKLIST_DOWNLOADED > ${BLOCKLIST_EXTRACTED}.tmp" ; } ||
            {
                log_failure_msg "Error $E_XEXTERNAL: 7z not installed."
                if grep -q WGET_OPTS "$CMD_CONF" && echo "$LIST_URL"|grep -q "iblocklist.com" ; then
                    echo "You are using blocklists from iblocklist.com and have in $CMD_CONF:"
                    echo "WGET_OPTS=\"$WGET_OPTS\""
                    echo "iblocklist.com compresses the blocklists with 7z if the user-agent is pglcmd (\$CMD_NAME)."
                    echo "Remove the user-agent or change it to pglcmd_x7z to receive gz blocklists."
                fi
                exit $E_XEXTERNAL
            }
            eval $EXTRACT_CMD || {
                log_failure_msg "Error $E_BLOCKLIST: Failed to extract $LIST_NAME."
                log_failure_msg "Removing $BLOCKLIST_DOWNLOADED."
                log_failure_msg "Check your configuration in $BLOCKLISTS_LIST and try a new \"$(basename $0) update\"."
                rm "$BLOCKLIST_DOWNLOADED" ||
                    { log_failure_msg "Error: rm exited with $?" ; exit 1 ; }
                exit $E_BLOCKLIST
                }
            ;;
        # gz packed file
        "$(/usr/bin/printf '\x1F\x8B\x08')"*)
            echo -n "detected gz... "
            zcat "$BLOCKLIST_DOWNLOADED" > "${BLOCKLIST_EXTRACTED}.tmp" || {
                log_failure_msg "Error $E_BLOCKLIST: Failed to extract $LIST_NAME."
                log_failure_msg "Removing $BLOCKLIST_DOWNLOADED."
                log_failure_msg "Check your configuration in $BLOCKLISTS_LIST and try a new \"$(basename $0) update\"."
                rm "$BLOCKLIST_DOWNLOADED" ||
                    { log_failure_msg "Error: rm exited with $?" ; exit 1 ; }
                exit $E_BLOCKLIST
                }
            ;;
        # zip packed file
        "$(/usr/bin/printf '\x50\x4B\x03\x04')"*)
            echo -n "detected zip... "
            test_external unzip || {
                log_failure_msg "Error $E_XEXTERNAL: unzip not installed."
                exit $E_XEXTERNAL
                }
            unzip -p "$BLOCKLIST_DOWNLOADED" > "${BLOCKLIST_EXTRACTED}.tmp" || {
                log_failure_msg "Error $E_BLOCKLIST: Failed to extract $LIST_NAME."
                log_failure_msg "Removing $BLOCKLIST_DOWNLOADED."
                log_failure_msg "Check your configuration in $BLOCKLISTS_LIST and try a new \"$(basename $0) update\"."
                rm "$BLOCKLIST_DOWNLOADED" ||
                    { log_failure_msg "Error: rm exited with $?" ; exit 1 ; }
                exit $E_BLOCKLIST
                }
            ;;
        # Assuming non-packed otherwise:
        *)
            echo -n "not packed... "
            ln -fs $BLOCKLIST_DOWNLOADED ${BLOCKLIST_EXTRACTED}.tmp ||
                { log_failure_msg " Error: ln exited with $?"; exit 1 ; }
            ;;
    esac
    # Count the lines in the list and check if there are any lines.
    if [ "$( wc -l < ${BLOCKLIST_EXTRACTED}.tmp )" -gt 0 ] ; then
        # Add a newline at end of file if it was missing.
        # This creates a copy of local blocklists even if nothing is changed instead of just linking.
        sed -e '$a\' "${BLOCKLIST_EXTRACTED}.tmp" > "${BLOCKLIST_EXTRACTED}" &&
            rm ${BLOCKLIST_EXTRACTED}.tmp ||
            { log_failure_msg "Error: $? Failed to save extracted blocklist ${BLOCKLIST_EXTRACTED}" ; exit 1 ; }
        echo "done."
    else
        # TODO: Remove list from e.g. UPDATE_SUCCESS
        log_warning_msg "${BLOCKLIST_EXTRACTED}.tmp is empty!"
        log_warning_msg "wc -l: $(wc -l ${BLOCKLIST_EXTRACTED}.tmp)"
        if [ -f "$BLOCKLIST_EXTRACTED" ] ; then
            log_warning_msg "Keeping old $BLOCKLIST_EXTRACTED."
            UPDATE_FAIL="$UPDATE_FAIL $LIST_NAME (new list was empty, keeping old, last modified: $(stat --format=%y $BLOCKLIST_DOWNLOADED | head -c 16));"
        else
            touch $BLOCKLIST_EXTRACTED
            UPDATE_FAIL="$UPDATE_FAIL $LIST_NAME (new list was empty, no old list available! Ignoring ...);"
        fi
    fi
}

# Function that updates blocklists and reloads daemon
update_blocklists () {
    # Remove the old MD5SUM file now, so that if anything goes wrong,
    # it's clear we have to rebuild the blocklist:
    [ -f "$MD5SUM_FILE" ] && {
        rm "$MD5SUM_FILE" || { log_failure_msg " Error: rm exited with $?" ; exit 1 ; }
        }

    UPDATE_FAIL=""          # Lists failed blocklist updates
    UPDATE_403=""           # Lists failed blocklist updates with "access forbidden"
    UPDATE_SUCCESS=""       # Lists successful blocklist updates
    UPDATE_SUCCESS_NA=""    # Lists blocklist where no update was available

    # Read the non-comment|not-empty lines from BLOCKLISTS_LIST.
    # Ignore all entries after # (comments).
    # LISTS_URL are all blocklists that are configured to be handled automatically.
    set_LISTS_URL

    # Only do the automatic updating, if any blocklist is configured to be handled automatically.
    if [ -n "$LISTS_URL" ] ; then
        echo "Updating blocklists ..."
        test_net

        for LIST in $LISTS_URL ; do
            get_blocklist
        done

        echo "Blocklists updated."

        if [ "$GIT" = 1 ] ; then
            cd "$BLOCKLISTS_DIR"
            test_external git ||
                {
                    log_failure_msg "Error $E_XEXTERNAL: git not installed."
                    exit $E_XEXTERNAL
                }
            [ -d .git ] || git init
            [ -f .gitignore ] || cat > .gitignore <<EOF
*/download*
EOF
            git add .
            git commit -m "Blocklist update $(date +%F" "%X" "%Z)."
fi
    else
        echo "Automatic blocklist management disabled."
    fi
}

# Function that builds the MASTER_BLOCKLIST
# - from all remote blocklists (configured in BLOCKLISTS_LIST) and
# - all local blocklists (all lists in LOCAL_BLOCKLIST_DIR, except those
#   starting with "." or ending with "~"),
# - but without lines that match case-insensitive IP_REMOVE.
# pgld is started with just this list.
# Ratio: We want to reload the daemon as fast as possible. Therefore do the whole
# blocklist management separately and save one premerged MASTER_BLOCKLIST to harddisk.
# Bad: for large local blocklists this means excess usage of harddisk space.
build_blocklist () {
    echo "Building blocklist ... "

    # DAEMON is needed to merge the single blocklists.
    test_DAEMON

    [ -d "$MASTER_BLOCKLIST_DIR" ] || {
        echo -n "Creating missing directory $MASTER_BLOCKLIST_DIR ..."
        mkdir -p "$MASTER_BLOCKLIST_DIR" && echo "."
        } || {
        log_failure_msg "Error $E_XCD: Missing directory $MASTER_BLOCKLIST_DIR."
        log_failure_msg "Check the $MASTER_BLOCKLIST_DIR setting."
        exit $E_XCD
    }
    BLOCKLISTSCAT=""

    # Remove the old MD5SUM file now, so that if anything goes wrong,
    # it's clear we have to rebuild the blocklist:
    [ -f "$MD5SUM_FILE" ] && {
    rm "$MD5SUM_FILE" || { log_failure_msg " Error: rm exited with $?" ; exit 1 ; }
    }

    # Move master blocklist to backup position. This way it is also removed,
    # in case the configuartion changed in that way, that no blocklists are
    # configured for the automatic blocklist management.
    [ -f "$MASTER_BLOCKLIST" ] &&
        mv $MASTER_BLOCKLIST ${MASTER_BLOCKLIST}~

    # Prepare removing lines from the blocklist with "grep":
    # remove pending ";" and replace all other ";" with "|" in IP_REMOVE.
    SINGLE_REMOVE="$( echo $IP_REMOVE | sed " s/;$// ; s/;/|/g " )"

    # Read the non-comment|not-empty lines from BLOCKLISTS_LIST.
    # Ignore all entries after # (comments).
    # LISTS_URL are all blocklists that are configured to be handled automatically.
    set_LISTS_URL
    if [ -n "$LISTS_URL" ] ; then
        test_BLOCKLISTS_DIR

        for LIST in $LISTS_URL ; do
            # This function depends on LIST:
            LIST_URL2LIST_NAME

            # Set name of the extracted blocklist.
            BLOCKLIST_EXTRACTED="$BLOCKLISTS_DIR/$LIST_NAME/extracted/$LIST_NAME"

            # Test if list is available:
            [ -f "$BLOCKLIST_EXTRACTED" ] ||
                get_blocklist || {
                log_failure_msg "Error $E_BLOCKLIST: $LIST_NAME not available."
                log_failure_msg "Check the entry $LIST"
                log_failure_msg "in $BLOCKLISTS_LIST. Aborting!"
                exit $E_BLOCKLIST
                }

            # Log which lines will be removed later
            if [ -n "$IP_REMOVE" ] ; then
                echo "Removing the following lines from $LIST_NAME:"
                grep -Ei "$SINGLE_REMOVE" "$BLOCKLIST_EXTRACTED" | sort
            fi

            # Remember all used lists
            BLOCKLISTSCAT="$BLOCKLISTSCAT $BLOCKLIST_EXTRACTED"
        done
    fi

    set_BLOCKLISTS_LOCAL
    if [ -n "$BLOCKLISTS_LOCAL" ] ; then
        for LIST in $BLOCKLISTS_LOCAL ; do

            # For local blocklist the same extract function is used as for remote lists
            LIST_NAME="$(basename $LIST)"
            BLOCKLIST_DOWNLOAD="$LIST"
            BLOCKLIST_DIR="${BLOCKLISTS_DIR}/blocklists-local"
            # A link to the original local list
            BLOCKLIST_DOWNLOADED="${BLOCKLIST_DIR}/${LIST_NAME}"
            # BLOCKLIST_DOWNLOADED is extracted to this file (or linked if it was unpacked)
            BLOCKLIST_EXTRACTED="${BLOCKLIST_DOWNLOADED}.extracted"
            [ -d "${BLOCKLIST_DIR}" ] || {
                echo -n "Creating missing directory ${BLOCKLIST_DIR} ..."
                mkdir -p ${BLOCKLIST_DIR} && echo "."
                }
            ln -fs ${BLOCKLIST_DOWNLOAD} ${BLOCKLIST_DOWNLOADED}
            extract_blocklist

            # Log which lines will be removed later
            if [ -n "$IP_REMOVE" ] ; then
                echo "Removing the following lines from ${LIST_NAME}:"
                grep -Ei "$SINGLE_REMOVE" "${BLOCKLIST_EXTRACTED}" | sort
            fi

            # Remember all used lists
            BLOCKLISTSCAT="$BLOCKLISTSCAT ${BLOCKLIST_EXTRACTED}"
        done
    fi

    if [ -z "$BLOCKLISTSCAT" ] ; then
        log_failure_msg "Error $E_BLOCKLIST: No blocklists configured or available."
        exit $E_BLOCKLIST
    else
        # Tells whether blocklist was built successfully
        BUILT=0

        # Build blocklist and remove some lines from the blocklists
        if [ -n "$IP_REMOVE" ] ; then
            # Cat together all single blocklists
            cat --squeeze-blank $BLOCKLISTSCAT |
            # Ignore comment lines and remove lines from IP_REMOVE (case-insensitive)
            grep -Eiv "^[[:space:]]*#|$SINGLE_REMOVE" |
            # Replace repeated whitespace with a single occurence
            tr -s [:space:] |
            # Delete everything complimentary to the following characters/regex
            # alphanumeric
            # space
            # :\*.-,[]
            # newline (return gets removed, so CR+LF gets LF)
            tr -cd '[:alnum:][:space:]:\\\*\.\-,[]\n' |
            # Only keep the last occurence of :
            sed 's/.*:/&|/' | tr -d : | tr "\|" ":" |
            # Premerge the blocklist
            $DAEMON -m > $MASTER_BLOCKLIST && BUILT=1
        # Build blocklist without removing some lines from the blocklists
        else
            # Cat together all single blocklists
            cat --squeeze-blank $BLOCKLISTSCAT |
            # Ignore comment lines
            grep -Ev "^[[:space:]]*#" |
            # Replace repeated whitespace with a single occurence
            tr -s [:space:] |
            # Delete everything complimentary to the following characters/regex
            # alphanumeric
            # space
            # :\*.-,[]
            # newline (return gets removed, so CR+LF gets LF)
            tr -cd '[:alnum:][:space:]:\\\*\.\-,[]\n' |
            # Only keep the last occurence of :
            sed 's/.*:/&|/' | tr -d : | tr "\|" ":" |
            # Premerge the blocklist, pgld's information is sent to STDERR
            # and therefore ends in pglcmd.log
            $DAEMON -m > $MASTER_BLOCKLIST && BUILT=1
        fi

        if [ "$BUILT" -eq 1 ] ; then
            echo "Blocklist built."
        else
            log_failure_msg "Error: build_blocklist failed."
            if [ -f ${MASTER_BLOCKLIST}~ ] ; then
                echo -n "Restoring $MASTER_BLOCKLIST ..."
                mv ${MASTER_BLOCKLIST}~ $MASTER_BLOCKLIST ||
                    { log_failure_msg " Error: mv exited with $?" ; exit 1 ; }
                log_end_msg 0
            else
                exit $E_BLOCKLIST
            fi
        fi
    fi

    # Save configuration settings on which this blocklist bases:
    set_md5sum
    echo "$MD5SUM" > "$MD5SUM_FILE"
}

# Function that tests if IPs get blocked
test_ipblocking () {
    # First check some preconditions for the test:
    test_DAEMON

    [ -f "$MASTER_BLOCKLIST" ] || {
        log_failure_msg " Error $E_BLOCKLIST: $MASTER_BLOCKLIST not available."
        exit $E_BLOCKLIST
        }

    # Detect the logfile, where hits are logged.
    if [ "$LOG_LOGFILE" -eq 1 ] ; then
        TEST_LOG="$DAEMON_LOG"
    elif [ "$LOG_SYSLOG" -eq 1 ] ; then
        TEST_LOG="/var/log/syslog"
    else
        echo "Error: $NAME has to be started with either LOG_SYSLOG=\"1\" or LOG_LOGFILE=\"1\" for \"test\" to work."
        exit $E_CONFIG
    fi

    echo "Testing $DESC:"
    # Check if daemon is running
    status_of_proc $DAEMON $NAME > /dev/null 2>&1
    RETVAL=$?
    case "$RETVAL" in
        0)    # Daemon is running
            true
            ;;
        3)    # Daemon is not running
            status_of_proc $DAEMON $NAME
            exit $?
            ;;
        *)    # Problematic daemon status. Be verbose and exit!
            echo "Problematic daemon status: $RETVAL"
            status_of_proc $DAEMON $NAME
            exit $?
            ;;
    esac

    # If logfile does not exist, reload daemon to reopen a new one.
    [ -f "$TEST_LOG" ] || kill -s HUP "$(pidofproc $DAEMON)"

    # Pick TEST_IP. Assume blocklist in text (not binary) format.
    TESTLINE="$(expr $$ % 100 + 10)"

    # Pick the last IP address from a random line in the MASTER_BLOCKLIST (earlier IPs often result in problems with ping)
    # Remove the leading zeros in the IPs.
    TEST_IP="$(head -n$TESTLINE $MASTER_BLOCKLIST | grep -Eo "$IPv4_REGEX" | tail -n1 )"
    echo "CAUTION: This is just a simple test to check if $DESC blocks"
    echo "outgoing connections. For this, an IP from the blocklist will be pinged. Then "
    echo "the test checks if this IP appears in $TEST_LOG."
    echo "$NAME MARKs packets to be blocked. This means you have to make sure that the"
    echo "MARKed packets are also blocked later (with appropriate iptables rules)."
    echo "To do that you can use LOG_IPTABLES=\"LOG --log-level info\""
    echo "This test does not check if you have sane iptables rules. Therefore success"
    echo "doesn't imply that everything is working as you expect it."
    echo ""
    echo "Also have a look at \"$(basename $0) status\"."
    echo ""

    echo "Trying to ping $TEST_IP from $MASTER_BLOCKLIST ..."
    LOG_LENGTH="$( wc -l < $TEST_LOG )" # remember log length before test
    ping -c1 -W2 $TEST_IP > /dev/null 2>&1
    RETVAL_PING=$? # the ping exit code
    # The ping exit status is 0 if ping succeeds and 1 if ping does not receive any reply packets.
    # On other error it exits with code 2.

    # Wait a second to give the daemon time to log the current block
    sleep 1
    LOG_LENGTH_NEW="$( wc -l < $TEST_LOG )" # new log length

    if [ "$LOG_LENGTH" -ne "$LOG_LENGTH_NEW" ] ; then    # log length changed
        tail -n$((${LOG_LENGTH_NEW}-${LOG_LENGTH})) $TEST_LOG |
            grep -q $TEST_IP
        RETVAL=$? # the grep exit status
        # The grep exit status is 0 if selected lines are found and 1 otherwise.
        # If an error occurred the grep exit status is 2.
    else
        RETVAL=1
    fi

    if [ "$RETVAL" -eq 0 ] ; then    # IP in logfile
        if [ "$RETVAL_PING" -eq 1 ] ; then    # No reply to ping
            echo "$NAME marked the IP to be blocked and the IP did not answer."
            echo "Test succeeded."
        elif [ "$RETVAL_PING" -eq 0 ] ; then    # Reply to ping
            echo "$NAME blocked the IP, but ping got an answer or failed."
            echo "Check the iptables settings and make sure that \"marked block\" packets really"
            echo "get blocked."
            RETVAL=2
        else
            echo "Some error occured with ping, no test result."
            RETVAL=2
        fi
    elif [ "$RETVAL" -eq 1 ] ; then    # IP not in logfile
        echo "$NAME did not mark the IP to be blocked."
        if [ "$RETVAL_PING" -eq 0 ] ; then    # Reply to ping
            echo "$TEST_IP answered. Test failed."
        elif [ "$RETVAL_PING" -eq 1 ] ; then    # No reply to ping
            echo "$TEST_IP did not answer the ping."
            echo ""
            echo "No clear test result! Trying \"$TRACEROUTE -n -m 2 ${TEST_IP} ${TRACEROUTE_PORT}\" now:"
            if [ -n "$TRACEROUTE" ] && test_external $TRACEROUTE ; then
                TRACE_LOG="${TMPDIR}/$(basename $0).test.log"
                $TRACEROUTE -n -m 2 $TEST_IP ${TRACEROUTE_PORT} > $TRACE_LOG 2>&1
                RETVAL_TRACEROUTE=$?    # the traceroute exit status
                cat $TRACE_LOG
                echo ""
                if [ "$RETVAL_TRACEROUTE" -eq 1 ] && grep -q "send: Operation not permitted" $TRACE_LOG ; then
                    echo "Probably the $TRACEROUTE packet was blocked by another iptables rule on your"
                    echo "machine. Everything might be ok."
                    RETVAL=0
                elif [ "$RETVAL_TRACEROUTE" -eq 0 ] && [ "$( wc -l < $TRACE_LOG )" -eq 2 ] ; then
                    # Wait a second to give the daemon time to log the current block
                    sleep 1
                    LOG_LENGTH_NEW="$( wc -l < $TEST_LOG )" # new log length
                    if [ "$LOG_LENGTH" -ne "$LOG_LENGTH_NEW" ] ; then    # log length changed
                        tail -n$(($LOG_LENGTH_NEW-$LOG_LENGTH)) $TEST_LOG |
                            grep -q $TEST_IP
                        RETVAL=$? # the grep exit status
                        # The grep exit status is 0 if selected lines are found and 1 otherwise.
                        # If an error occurred the grep exit status is 2.
                        if [ "$RETVAL" -eq 0 ] ; then
                            echo "Now the packet was blocked by pglcmd. Everything might be ok."
                            RETVAL=0
                        fi
                    else
                        echo "The packet did not leave your machine, but wasn't blocked either. Confusing."
                        echo "$TRACEROUTE return code was $RETVAL_TRACEROUTE."
                    fi
                elif [ "$RETVAL_TRACEROUTE" -eq 0 ] && [ "$(wc -l < $TRACE_LOG )" -eq 3 ] ; then
                    echo "The $TRACEROUTE packet was not blocked on your machine. There is a problem!"
                else
                    echo "Probably $TEST_IP is down/doesn't answer to pings."
                    echo "This still means that $NAME is not working!"
                fi
            else
                echo "$TRACEROUTE not installed."
            fi
        else
            echo "Some error occured with ping, no test result."
            RETVAL=2
        fi
    else    # grep error
        echo "Some error occured with grep, no test result."
        RETVAL=2
    fi
    return $RETVAL
}

# Just dump stats
dump_stats () {
    SIG_STATS="USR2"
    pgl_stats
}

# Dump and reset stats
reset_stats () {
    SIG_STATS="USR1"
    pgl_stats
}

# generic stats function (SIGUSR1/SIGUSR2)
pgl_stats () {
    status_of_proc $DAEMON $NAME > /dev/null 2>&1 || {
        echo "$DAEMON is not running."
        exit 1
        }
    if [ "$LOG_LOGFILE" = 1 ] ; then
        # If logfile does not exist, reload daemon to reopen a new one.
        [ -f "$DAEMON_LOG" ] || kill -s HUP "$(pidofproc $DAEMON)"
        CURLINE="$( wc -l < $DAEMON_LOG )"
        kill -s $SIG_STATS "$(pidofproc $DAEMON)"
        (
        sleep 5
        tail -n+$(($CURLINE + 1)) $DAEMON_LOG | grep STATS:
        ) &
    elif [ "$LOG_SYSLOG" = 1 ] ; then
        CURLINE="$( grep pgld: /var/log/syslog | wc -l )"
        kill -s $SIG_STATS "$(pidofproc $DAEMON)"
        (
        sleep 5
        grep pgld: /var/log/syslog | tail -n+$(($CURLINE + 1)) | grep STATS:
        ) &
    else
        echo "Logging to logfile or syslog must be enabled to dump stats."
    fi
}

email_stats () {
    # Check if pgl is configured to mail the stats, and if daemon is running
    # (otherwise stats are not available).
    # After "reset_stats" sleep longer than the forked process in "reset_stats" itself,
    # so that we catch its output.
    if [ $STATS_MAILTO ] && status_of_proc $DAEMON $NAME >/dev/null 2>&1 && test_sendmail ; then
        echo -n "Emailing stats"
        SUBJECT="$NAME hit statistics"
        cat<<EOF | $SENDMAIL -t &
To: $STATS_MAILTO
Subject: $SUBJECT

$(reset_stats ; sleep 6)

EOF
        log_end_msg "$?"
    fi
}

search () {
    # Read the non-comment|not-empty lines from BLOCKLISTS_LIST.
    # Ignore all entries after # (comments).
    set_LISTS_URL
    echo "Checking your currently used blocklists for \"$SEARCHPATTERN\""
    echo "(case-insensitive regular expression):"
    for LIST in $LISTS_URL ; do
        # This function depends on LIST:
        LIST_URL2LIST_NAME
        BLOCKLIST="$BLOCKLISTS_DIR/$LIST_NAME/extracted/$LIST_NAME"
        # Exit immediately with zero status if any match is found
        grep -qEi "$SEARCHPATTERN" "$BLOCKLIST" && {
            echo
            echo "$LIST_NAME ($LIST):"
            grep -Ei "$SEARCHPATTERN" "$BLOCKLIST"
            # Remember that current list contains SEARCHPATTERN
            HITLIST="$HITLIST $LIST"
            }
    done
    echo
    echo "\"$SEARCHPATTERN\" was found in these lists:"
    for LIST in $HITLIST ; do
        # This function depends on LIST:
        LIST_URL2LIST_NAME
        echo "$LIST_NAME ($LIST)"
    done
    echo
    echo "If you don't want to block the above shown ranges (with possibly changing"
    echo "pattern matches in the future), then you may add"
    echo "IP_REMOVE=\"$SEARCHPATTERN\" in $CMD_CONF"
    echo "(separate multiple values with a semi-colon \";\")."
    echo "Or you may remove some of these lists from $BLOCKLISTS_LIST."
}
